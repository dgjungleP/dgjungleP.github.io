<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>100dayscode-3 再看RxJava:Scheduler</title>
      <link href="/2023/04/01/100dayscode-3/"/>
      <url>/2023/04/01/100dayscode-3/</url>
      
        <content type="html"><![CDATA[<p>经过昨天的学习，我们认识到了可以如何去消费我们<code>Flowable</code>创建出来的消息，那么现在存在一个疑问，那么它是在那个线程去执行的呢。我们用一个新的方式<code>range</code>去创建一个例子尝试一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSchedule</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; flowable = Flowable.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Disposable</span> <span class="variable">subscribe</span> <span class="operator">=</span> flowable</span><br><span class="line">            .subscribe(data -&gt; System.out</span><br><span class="line">                    .println(<span class="string">&quot;Thread:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】 消费了 data【&quot;</span> + data + <span class="string">&quot;】&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread:【main】 消费了 data【0】</span><br><span class="line">Thread:【main】 消费了 data【1】</span><br><span class="line">Thread:【main】 消费了 data【2】</span><br><span class="line">Thread:【main】 消费了 data【3】</span><br><span class="line">Thread:【main】 消费了 data【4】</span><br><span class="line">Thread:【main】 消费了 data【5】</span><br><span class="line">Thread:【main】 消费了 data【6】</span><br><span class="line">Thread:【main】 消费了 data【7】</span><br><span class="line">Thread:【main】 消费了 data【8】</span><br><span class="line">Thread:【main】 消费了 data【9】</span><br></pre></td></tr></table></figure><p>那么如果我们要让他<code>异步执行</code>该怎么办呢？经过对 API 的排查我们发现了几个特别的方法签名：</p><blockquote><ol><li><code>public final Flowable&lt;T&gt; subscribeOn(@NonNull Scheduler scheduler)</code></li><li><code>public final Flowable&lt;T&gt; subscribeOn(@NonNull Scheduler scheduler, boolean requestOn)</code></li><li><code>public final Flowable&lt;T&gt; unsubscribeOn(@NonNull Scheduler scheduler)</code></li></ol></blockquote><p>从这个<code>Scheduler</code>的文档里面我们发现这样一句话：<br>You can get various standard, RxJava-specific instances of this class via the static methods of the io.reactivex.rxjava3.schedulers.Schedulers utility class.</p><p>那么在不太熟悉的情况下，我们就按照官方文档的建议我们去看一下这个<code>Schedulers</code>里面携带了什么标准内容给我们使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Scheduler IO;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Scheduler COMPUTATION;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Scheduler SINGLE;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Scheduler TRAMPOLINE;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Scheduler NEW_THREAD;</span><br></pre></td></tr></table></figure><p>我们分别来使用一下看一下效果</p><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScheduleIo</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; flowable = Flowable.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    flowable = flowable</span><br><span class="line">            .subscribeOn(Schedulers.io());</span><br><span class="line">    <span class="type">Disposable</span> <span class="variable">subscribe</span> <span class="operator">=</span> flowable</span><br><span class="line">            .subscribe(data -&gt; System.out</span><br><span class="line">                    .println(<span class="string">&quot;Thread:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】 消费了 data【&quot;</span> + data + <span class="string">&quot;】&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【0】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【1】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【2】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【3】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【4】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【5】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【6】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【7】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【8】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【9】</span><br></pre></td></tr></table></figure><h4 id="使用的结论"><a href="#使用的结论" class="headerlink" title="使用的结论"></a>使用的结论</h4><p>建立一单独的线程来处理数据，看起来时在背后建立了一个线程池，那么我们看一下官方文档是怎么介绍的<br>Returns a default, shared Scheduler instance intended for IO-bound work.<br>This can be used for asynchronously performing blocking IO.<br>The implementation is backed by a pool of single-threaded ScheduledExecutorService instances that will try to reuse previously started instances used by the worker returned by Scheduler</p><h3 id="COMPUTATION"><a href="#COMPUTATION" class="headerlink" title="COMPUTATION"></a>COMPUTATION</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScheduleIo</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; flowable = Flowable.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    flowable = flowable</span><br><span class="line">            .subscribeOn(Schedulers.io());</span><br><span class="line">    <span class="type">Disposable</span> <span class="variable">subscribe</span> <span class="operator">=</span> flowable</span><br><span class="line">            .subscribe(data -&gt; System.out</span><br><span class="line">                    .println(<span class="string">&quot;Thread:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】 消费了 data【&quot;</span> + data + <span class="string">&quot;】&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【0】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【1】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【2】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【3】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【4】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【5】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【6】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【7】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【8】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【9】</span><br></pre></td></tr></table></figure><h4 id="使用的结论-1"><a href="#使用的结论-1" class="headerlink" title="使用的结论"></a>使用的结论</h4><p>建立一单独的线程来处理数据，看起来时在背后建立了一个线程池，那么我们看一下官方文档是怎么介绍的<br>Returns a default, shared Scheduler instance intended for computational work.<br>This can be used for event-loops, processing callbacks and other computational work.<br>It is not recommended to perform blocking, IO-bound work on this scheduler. Use io() instead.<br>从说明里面看，如果执行过程中没有阻塞行为的话，可以使用这个类型</p><h3 id="SINGLE"><a href="#SINGLE" class="headerlink" title="SINGLE"></a>SINGLE</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScheduleComputation</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; flowable = Flowable.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    flowable = flowable</span><br><span class="line">            .subscribeOn(Schedulers.computation());</span><br><span class="line">    <span class="type">Disposable</span> <span class="variable">subscribe</span> <span class="operator">=</span> flowable</span><br><span class="line">            .subscribe(data -&gt; System.out</span><br><span class="line">                    .println(<span class="string">&quot;Thread:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】 消费了 data【&quot;</span> + data + <span class="string">&quot;】&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h4><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【0】</span><br><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【1】</span><br><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【2】</span><br><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【3】</span><br><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【4】</span><br><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【5】</span><br><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【6】</span><br><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【7】</span><br><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【8】</span><br><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【9】</span><br></pre></td></tr></table></figure><h4 id="使用的结论-2"><a href="#使用的结论-2" class="headerlink" title="使用的结论"></a>使用的结论</h4><p>建立一单独的线程来处理数据，看起来时在背后建立了一个线程池，那么我们看一下官方文档是怎么介绍的<br>Returns a default, shared, single-thread-backed Scheduler instance for work requiring strongly-sequential execution on the same background thread.</p><h3 id="TRAMPOLINE"><a href="#TRAMPOLINE" class="headerlink" title="TRAMPOLINE"></a>TRAMPOLINE</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScheduleComputation</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; flowable = Flowable.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    flowable = flowable</span><br><span class="line">            .subscribeOn(Schedulers.computation());</span><br><span class="line">    <span class="type">Disposable</span> <span class="variable">subscribe</span> <span class="operator">=</span> flowable</span><br><span class="line">            .subscribe(data -&gt; System.out</span><br><span class="line">                    .println(<span class="string">&quot;Thread:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】 消费了 data【&quot;</span> + data + <span class="string">&quot;】&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h4><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread:【main】 消费了 data【0】</span><br><span class="line">Thread:【main】 消费了 data【1】</span><br><span class="line">Thread:【main】 消费了 data【2】</span><br><span class="line">Thread:【main】 消费了 data【3】</span><br><span class="line">Thread:【main】 消费了 data【4】</span><br><span class="line">Thread:【main】 消费了 data【5】</span><br><span class="line">Thread:【main】 消费了 data【6】</span><br><span class="line">Thread:【main】 消费了 data【7】</span><br><span class="line">Thread:【main】 消费了 data【8】</span><br><span class="line">Thread:【main】 消费了 data【9】</span><br></pre></td></tr></table></figure><h4 id="使用的结论-3"><a href="#使用的结论-3" class="headerlink" title="使用的结论"></a>使用的结论</h4><p>从结果来看，它还是使用了当前线程处理，因为现在的执行线程是 Main 线程，所以我们拿到的也是 Main 线程<br>The default implementation’s Scheduler.scheduleDirect(Runnable) methods execute the tasks on the current thread without any queueing and the timed overloads use blocking sleep as well</p><h3 id="NEW-THREAD"><a href="#NEW-THREAD" class="headerlink" title="NEW_THREAD"></a>NEW_THREAD</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScheduleComputation</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; flowable = Flowable.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    flowable = flowable</span><br><span class="line">            .subscribeOn(Schedulers.computation());</span><br><span class="line">    <span class="type">Disposable</span> <span class="variable">subscribe</span> <span class="operator">=</span> flowable</span><br><span class="line">            .subscribe(data -&gt; System.out</span><br><span class="line">                    .println(<span class="string">&quot;Thread:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】 消费了 data【&quot;</span> + data + <span class="string">&quot;】&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果-4"><a href="#结果-4" class="headerlink" title="结果"></a>结果</h4><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【0】</span><br><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【1】</span><br><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【2】</span><br><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【3】</span><br><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【4】</span><br><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【5】</span><br><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【6】</span><br><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【7】</span><br><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【8】</span><br><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【9】</span><br></pre></td></tr></table></figure><h4 id="使用的结论-4"><a href="#使用的结论-4" class="headerlink" title="使用的结论"></a>使用的结论</h4><p>建立一单独的线程来处理数据，看起来时在背后建立了一个线程池，那么我们看一下官方文档是怎么介绍的<br>Returns a default, shared Scheduler instance that creates a new Thread for each unit of work.</p><p>综上俩看，基本上每一个特定的标准都是创建了一个线程池来办这个事情，那么现实真的是不是呢，我们后面在真正的使用的时候，我们再去追一下源码看看具体情况，但是现在有一个问题，如果我自己有一个线程池，我能不能使用我自己的线程池呢，从方法签名中我们有找到几个特定的方法：</p><blockquote><ol><li><code>public static Scheduler from(@NonNull Executor executor)</code></li><li><code>public static Scheduler from(@NonNull Executor executor, boolean interruptibleWorker)</code></li><li><code>public static Scheduler from(@NonNull Executor executor, boolean interruptibleWorker, boolean fair</code></li></ol></blockquote><p>从这里我们看到，确实我们能够使用自己的线程池，所以接下来我们看一下我们应该如何去使用我们现在学习过的知识点。</p><p>相关代码地址:<a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> rxjava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100DaysCode-Day02 再看RxJava:Subscribe</title>
      <link href="/2023/03/31/100dayscode-2/"/>
      <url>/2023/03/31/100dayscode-2/</url>
      
        <content type="html"><![CDATA[<p>在昨天的使用我们，我们是用了最简单的 RxJava 的模型，在这里我们回顾一下我们是如何订阅了消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Disposable</span> <span class="variable">subscribe</span> <span class="operator">=</span> flowable.subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p>这里使用了 subscibe 方法的一个重载方法，其实它总共有其中不同的声明</p><blockquote><ol><li><code>public final Disposable subscribe()</code></li><li><code>public final Disposable subscribe(@NonNull Consumer&lt;? super T&gt; onNext)</code></li><li><code>public final Disposable subscribe(@NonNull Consumer&lt;? super T&gt; onNext, @NonNull Consumer&lt;? super Throwable&gt; onError)</code></li><li><code>public final Disposable subscribe(@NonNull Consumer&lt;? super T&gt; onNext, @NonNull Consumer&lt;? super Throwable&gt; onError,@NonNull Action onComplete)</code></li><li><code>public final Disposable subscribe(@NonNull Consumer&lt;? super T&gt; onNext,@NonNull Consumer&lt;? super Throwable&gt; onError,@NonNull Action onComplete,@NonNull DisposableContainer container)</code></li><li><code>public final void subscribe(@NonNull Subscriber&lt;? super T&gt; subscriber)</code></li><li><code>public final void subscribe(@NonNull FlowableSubscriber&lt;? super T&gt; subscriber)</code></li></ol></blockquote><p>其中我们主要来看一下序号<code>6</code>的方法重载，其他的方法重载，是为了方便取使用而做的一些简化。<br>从签名中我们就注意到了一个对象<code>Subscriber&lt;? super T&gt;</code>，那么它的组成部分到底是什么样的，我们来看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Subscriber&lt;Integer&gt; subscriber = <span class="keyword">new</span> <span class="title class_">Subscriber</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Subscription s)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(Integer o)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从接口的方法签名上，我们就可以明确的看到，这里有四个接口方法需要我们实现，那么就可以<code>Flowable</code>的消息进行订阅了。如果要达到昨天效果，我们只需要取实现对应的<code>onNext</code>和<code>onSubscribe</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Flowable&lt;Integer&gt; flowable = Flowable.just(<span class="number">1</span>);</span><br><span class="line">Subscriber&lt;Integer&gt; subscriber = <span class="keyword">new</span> <span class="title class_">Subscriber</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Subscription s)</span> &#123;</span><br><span class="line">      s.request(Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(Integer o)</span> &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">flowable.subscribe(subscriber);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一定要注意<code>onSubscribe</code>方法，按照接口的说明，如果没有对<code>Subscription</code>进行 request 操作的话，那么其实<code>Publisher</code>并不会发送消息，这里为什么用<code>s.request(Long.MAX_VALUE)</code>,其实当你去看对应的重载发放的时候，你就会发现当我们用其他的重载方法的时候，他会去做这样一个组装，帮我们构造一个<code>LambdaSubscriber</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LambdaSubscriber&lt;T&gt; ls = <span class="keyword">new</span> <span class="title class_">LambdaSubscriber</span>&lt;&gt;(onNext, onError, onComplete, FlowableInternalHelper.RequestMax.INSTANCE);</span><br></pre></td></tr></table></figure><p>那么这里就看得到有一个<code>单例对象FlowableInternalHelper.RequestMax.INSTANCE</code>,那我们再看一下它指代的是什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RequestMax</span> <span class="keyword">implements</span> <span class="title class_">Consumer</span>&lt;Subscription&gt; &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Subscription t)</span> &#123;</span><br><span class="line">        t.request(Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这就是为什么我们也用这个的原因，那我们可不可以用其他的数值来代替呢？，当我们把他换成任意一个数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Subscription s)</span> &#123;</span><br><span class="line">    s.request(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会发现，它在现在的上下文上，确实也得到了我们的预期，但是如果我们将上下文做一个处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flowable&lt;Integer&gt; flowable = Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>那么这个时候，你就会发现它打印了 1 之后就再也没有其他的打印了。所以我们再去看一下 <code>Subscription</code>的<code>request(long)</code>方法的说明文档，我们就会发现，它说明了这里是用来限制到底能够最多拿到<code>Publisher</code>发送的多少个消息，所以我们在这里可以大胆的假设它的使用场景：</p><ul><li>定量的心跳包发送</li><li>请求限流<br>那么剩下的<code>onNext</code>方法、<code>onError</code>方法、<code>onComplete</code>方法我们就见名知意了，分别是用于处理每一次获取到消息、发生异常时的处理、消息完全接收完毕之后的处理。到后续我们需要的时候再回过头来继续看看，他们有没有什么可以利用的点。</li></ul><p>相关代码地址:<a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> rxjava </tag>
            
            <tag> 小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100DaysCode-Day01 再看RxJava:Hello Flowable</title>
      <link href="/2023/03/30/100dayscode-1/"/>
      <url>/2023/03/30/100dayscode-1/</url>
      
        <content type="html"><![CDATA[<p>在我的工作中，我使用最多的场景就是用 RxJava 帮助我处理异步任务的问题，所以对于 RxJava 的起步我应该是从<code>Flowable</code>开始切入的。那么这里就浅讲一下<code>Flowable</code>的使用方式（总的来说 RxJava 的几乎所有的<code>被观察者</code>都是这样创建的）。</p><blockquote><p>它可能不对，但是我确实是这样入坑的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createFlowable</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; flowable = Flowable.just(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了这样的一个简单的包含一个可被监控元素的 Flowable 的被监听者已经创建好了，当运行代码的时候，会发现什么也没有发生，是因为只有被监听者准备好了，他还没有被监听。所以我们就需要让他被监听起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createFlowable</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; flowable = Flowable.just(<span class="number">1</span>);</span><br><span class="line">    flowable.subscribe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样运行之后发现，还是什么变化也没有，是因为监听者并没有做任何的事情，那么就需要给他定制一个当监听到对应的数据的时候的一个行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createFlowable</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; flowable = Flowable.just(<span class="number">1</span>);</span><br><span class="line">    <span class="type">Disposable</span> <span class="variable">subscribe</span> <span class="operator">=</span> flowable.subscribe(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样执行后，我们就会发现，我们声明了他只需要简单的打印一下拿到的数据就可以了，运行之后我们也拿到了对应的结果</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>至此一个简易的 RxJava 的模型就已经完成了，他可以说是 RxJava 的全部内容，也可以说是冰山一角，剩下的中间操作、监听者的配置以及<code>Disposable</code>则是接下来需要深入理解的东西。</p><p>代码地址:<a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> rxjava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开始</title>
      <link href="/2023/03/28/test-layout/"/>
      <url>/2023/03/28/test-layout/</url>
      
        <content type="html"><![CDATA[<p>现在 从这里开始启程吧</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活随记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
