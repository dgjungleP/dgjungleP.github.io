<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>100dayscode-20 SPI机制浅读:TypeConversion SPI</title>
      <link href="/2023/04/18/100dayscode-20/"/>
      <url>/2023/04/18/100dayscode-20/</url>
      
        <content type="html"><![CDATA[<p>誊写中</p><p>相关代码地址:<br><a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> spi </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100dayscode-19 SPI机制浅读:Spring SPI</title>
      <link href="/2023/04/17/100dayscode-19/"/>
      <url>/2023/04/17/100dayscode-19/</url>
      
        <content type="html"><![CDATA[<blockquote><p>之前我们一起看来一下 Java 原生是如何支持<code>SPI</code>的，那么更进一步，我们来看一下我们常用的<br>Spring 是如何实现他自己的<code>SPI</code>的，它又有什么不一样的地方呢</p></blockquote><p>在使用 SpringBoot 的时候我们都会有疑惑，SpringBoot 的<code>自动装配</code>到底是如何实现的，为什么我用一个注解或者甚至不用注解直接引入包就能实现我们编写的第三方组件能够自动注入，其实其原理的背后就是<code>SPI</code>,那么 SpringBoot 又是怎么样来支持<code>SPI</code>的呢？</p><h2 id="SpringFactoriesLoader"><a href="#SpringFactoriesLoader" class="headerlink" title="SpringFactoriesLoader"></a>SpringFactoriesLoader</h2><h3 id="发现它"><a href="#发现它" class="headerlink" title="发现它"></a>发现它</h3><p>如有有兴趣去追查一下<code>SpringAplication</code>的<code>run</code>方法的话，我们可以看到接下来的一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt; primarySource, String... args)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> run(<span class="keyword">new</span> <span class="title class_">Class</span>&lt;?&gt;[] &#123; primarySource &#125;, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ConfigurableApplicationContext <span class="title function_">run</span><span class="params">(Class&lt;?&gt;[] primarySources, String[] args)</span> &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">SpringApplication</span>(primarySources).run(args);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="title function_">SpringApplication</span><span class="params">(ResourceLoader resourceLoader, Class&lt;?&gt;... primarySources)</span> &#123;</span><br><span class="line">   <span class="built_in">this</span>.resourceLoader = resourceLoader;</span><br><span class="line">   Assert.notNull(primarySources, <span class="string">&quot;PrimarySources must not be null&quot;</span>);</span><br><span class="line">   <span class="built_in">this</span>.primarySources = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(Arrays.asList(primarySources));</span><br><span class="line">   <span class="built_in">this</span>.webApplicationType = WebApplicationType.deduceFromClasspath();</span><br><span class="line">   setInitializers((Collection) getSpringFactoriesInstances(ApplicationContextInitializer.class));</span><br><span class="line">   setListeners((Collection) getSpringFactoriesInstances(ApplicationListener.class));</span><br><span class="line">   <span class="built_in">this</span>.mainApplicationClass = deduceMainApplicationClass();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Spring</code>的启动最后，还是会落到这个<code>SpringApplication</code>类的初始化里面来，同时我们看到，<code>SpringApplication</code>在类初始化的过程中，执行了一些类的注册，那么我们就继续追查一下这个<code>getSpringFactoriesInstances</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;T&gt; Collection&lt;T&gt; <span class="title function_">getSpringFactoriesInstances</span><span class="params">(Class&lt;T&gt; type, Class&lt;?&gt;[] parameterTypes, Object... args)</span> &#123;</span><br><span class="line">   <span class="type">ClassLoader</span> <span class="variable">classLoader</span> <span class="operator">=</span> getClassLoader();</span><br><span class="line">   <span class="comment">// Use names and ensure unique to protect against duplicates</span></span><br><span class="line">   Set&lt;String&gt; names = <span class="keyword">new</span> <span class="title class_">LinkedHashSet</span>&lt;&gt;(SpringFactoriesLoader.loadFactoryNames(type, classLoader));</span><br><span class="line">   List&lt;T&gt; instances = createSpringFactoriesInstances(type, parameterTypes, classLoader, args, names);</span><br><span class="line">   AnnotationAwareOrderComparator.sort(instances);</span><br><span class="line">   <span class="keyword">return</span> instances;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么到这里我们就看到，我们需要的主角出现了，我们看到除开下面是构造我们需要的实例之外，最重要的就是去找到，这些实例具体是那些实现类，那么<code>SpringFactoriesLoader</code>就在这里充当了这样一个服务发现的功能。</p><h3 id="挖掘它"><a href="#挖掘它" class="headerlink" title="挖掘它"></a>挖掘它</h3><p>那么现在我们就看看，这个<code>loadFactoryNames</code>做了些什么事情：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title function_">loadFactoryNames</span><span class="params">(Class&lt;?&gt; factoryType, <span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">   <span class="type">String</span> <span class="variable">factoryTypeName</span> <span class="operator">=</span> factoryType.getName();</span><br><span class="line">   <span class="keyword">return</span> loadSpringFactories(classLoader).getOrDefault(factoryTypeName, Collections.emptyList());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, List&lt;String&gt;&gt; <span class="title function_">loadSpringFactories</span><span class="params">(<span class="meta">@Nullable</span> ClassLoader classLoader)</span> &#123;</span><br><span class="line">   MultiValueMap&lt;String, String&gt; result = cache.get(classLoader);</span><br><span class="line">   <span class="keyword">if</span> (result != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">try</span> &#123;</span><br><span class="line">      Enumeration&lt;URL&gt; urls = (classLoader != <span class="literal">null</span> ?</span><br><span class="line">            classLoader.getResources(FACTORIES_RESOURCE_LOCATION) :</span><br><span class="line">            ClassLoader.getSystemResources(FACTORIES_RESOURCE_LOCATION));</span><br><span class="line">      result = <span class="keyword">new</span> <span class="title class_">LinkedMultiValueMap</span>&lt;&gt;();</span><br><span class="line">      <span class="keyword">while</span> (urls.hasMoreElements()) &#123;</span><br><span class="line">         <span class="type">URL</span> <span class="variable">url</span> <span class="operator">=</span> urls.nextElement();</span><br><span class="line">         <span class="type">UrlResource</span> <span class="variable">resource</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">UrlResource</span>(url);</span><br><span class="line">         <span class="type">Properties</span> <span class="variable">properties</span> <span class="operator">=</span> PropertiesLoaderUtils.loadProperties(resource);</span><br><span class="line">         <span class="keyword">for</span> (Map.Entry&lt;?, ?&gt; entry : properties.entrySet()) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">factoryTypeName</span> <span class="operator">=</span> ((String) entry.getKey()).trim();</span><br><span class="line">            <span class="keyword">for</span> (String factoryImplementationName : StringUtils.commaDelimitedListToStringArray((String) entry.getValue())) &#123;</span><br><span class="line">               result.add(factoryTypeName, factoryImplementationName.trim());</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      cache.put(classLoader, result);</span><br><span class="line">      <span class="keyword">return</span> result;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">IllegalArgumentException</span>(<span class="string">&quot;Unable to load factories from location [&quot;</span> +</span><br><span class="line">            FACTORIES_RESOURCE_LOCATION + <span class="string">&quot;]&quot;</span>, ex);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实从上面我们就能看得到，它其实和<code>ServerLoader</code>做了同样的事情，都是去找到一个资源文件，然后将资源文件的数据解析出来，只不过这里的资源文件路径是:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">FACTORIES_RESOURCE_LOCATION</span> <span class="operator">=</span> <span class="string">&quot;META-INF/spring.factories&quot;</span>;</span><br></pre></td></tr></table></figure><blockquote><p>但是在 SpringBoot 2.7 之后官方已经不建议使用这个路径了，改为了<code>META-INF/spring/org.springframework.boot.autoconfigure.AutoConfiguration.imports</code>,并且在废弃通知中也做出了回应<br><code>Loading auto-configurations from </code>spring.factories<code> is deprecated</code></p></blockquote><p>所以很多自定义 starter 包的朋友都对这个文件夹不陌生，这就是为什么我们只要在这个路径中指明我们的实现类之后，就可以通过第三方插件的方式来改变我们 SpringBoot 的一些行为了，当然具体的自动装配还有更多的其他的一些组件来组合才完成了最终效果，这个我们后期再来细细的品味。</p><h3 id="它改变了什么"><a href="#它改变了什么" class="headerlink" title="它改变了什么"></a>它改变了什么</h3><ul><li>我们可以看到它提供了一个类加载器和装配类的缓存，可以避免多次重复的读取配置配置，但是类的装载还是直接调用<code>ClassLoader</code>进行的装载</li></ul><p>相关代码地址:<br><a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> spi </tag>
            
            <tag> spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100dayscode-18 双亲委派和打破双亲委派</title>
      <link href="/2023/04/16/100dayscode-18/"/>
      <url>/2023/04/16/100dayscode-18/</url>
      
        <content type="html"><![CDATA[<pre><code>紧接着上次说到的这个线程上下文类加载器，我们看一下他在`ServceLoader`中到底做了些什么事情</code></pre><h2 id="使用Thread-currentThread-getContextClassLoader"><a href="#使用Thread-currentThread-getContextClassLoader" class="headerlink" title="使用Thread.currentThread().getContextClassLoader()"></a>使用<code>Thread.currentThread().getContextClassLoader()</code></h2><p>在源码中追踪的时候，我们发现最后这个类加载器被注入到了<code>LazyIterator</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">reload</span><span class="params">()</span> &#123;</span><br><span class="line">    providers.clear();</span><br><span class="line">    lookupIterator = <span class="keyword">new</span> <span class="title class_">LazyIterator</span>(service, loader);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="title function_">ServiceLoader</span><span class="params">(Class&lt;S&gt; svc, ClassLoader cl)</span> &#123;</span><br><span class="line">    service = Objects.requireNonNull(svc, <span class="string">&quot;Service interface cannot be null&quot;</span>);</span><br><span class="line">    loader = (cl == <span class="literal">null</span>) ? ClassLoader.getSystemClassLoader() : cl;</span><br><span class="line">    acc = (System.getSecurityManager() != <span class="literal">null</span>) ? AccessController.getContext() : <span class="literal">null</span>;</span><br><span class="line">    reload();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而在<code>LayzIterator</code>中我们发现它主要用到了两个地方</p><ul><li>资源数据的加载</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasNextService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextName != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configs == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">fullName</span> <span class="operator">=</span> PREFIX + service.getName();</span><br><span class="line">            <span class="keyword">if</span> (loader == <span class="literal">null</span>)</span><br><span class="line">                configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">            <span class="keyword">else</span>                configs = loader.getResources(fullName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            fail(service, <span class="string">&quot;Error locating configuration files&quot;</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pending == <span class="literal">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pending = parse(service, configs.nextElement());</span><br><span class="line">    &#125;</span><br><span class="line">    nextName = pending.next();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br></pre></td></tr></table></figure><ul><li>类加载</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> S <span class="title function_">nextService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasNextService())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">NoSuchElementException</span>();</span><br><span class="line">    <span class="type">String</span> <span class="variable">cn</span> <span class="operator">=</span> nextName;</span><br><span class="line">    nextName = <span class="literal">null</span>;</span><br><span class="line">    Class&lt;?&gt; c = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        c = Class.forName(cn, <span class="literal">false</span>, loader);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; not found&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!service.isAssignableFrom(c)) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">&quot;Provider &quot;</span> + cn  + <span class="string">&quot; not a subtype&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="type">S</span> <span class="variable">p</span> <span class="operator">=</span> service.cast(c.newInstance());</span><br><span class="line">        providers.put(cn, p);</span><br><span class="line">        <span class="keyword">return</span> p;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">        fail(service,</span><br><span class="line">             <span class="string">&quot;Provider &quot;</span> + cn + <span class="string">&quot; could not be instantiated&quot;</span>,</span><br><span class="line">             x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>();          <span class="comment">// This cannot happen</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么为了类加载需要用这个特殊的类加载器呢，这个我们就不得不来聊一下，Java 的类加载机制<code>双亲委派加载</code></p><h1 id="双亲委派加载"><a href="#双亲委派加载" class="headerlink" title="双亲委派加载"></a>双亲委派加载</h1><p>学习 Java 的时候，我们经常会听到这个词<code>双亲委派</code>，那么为什么叫<code>双亲委派</code>呢，它又给我们带来了什么？帮助我们解决了什么问题呢？</p><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><p>我们耳熟能详的类加载器有以下几种：</p><ul><li><code>BootstrapClassLoader</code>：主要负责以加载核心类库，构造<code>ExtClassLoader</code>和<code>AppClassLoader</code></li><li><code>ExtClassLoader</code>：主要负责加载<code>jre/lib/ext</code>目录下的一些扩展 jar 包</li><li><code>AppClassLoader</code>：主要负责加载应用程序的主函数类</li></ul><p>我们根据这些类加载器的源码可以看到它的加载逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line"><span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent != <span class="literal">null</span>) &#123;</span><br><span class="line">            c = parent.loadClass(name, <span class="literal">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            c = findBootstrapClassOrNull(name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line"> ....</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (c == <span class="literal">null</span>) &#123;</span><br><span class="line">        c = findClass(name);</span><br><span class="line">    &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里是精简版的逻辑，我们可以看到，他的实际逻辑就是</p><ol><li>先确认当前类是不是以及加载过了，加载过了就不再处理</li><li>如果没有加载先调用父加载（这里的父子关系，并不是继承中的父子关系，而是组合中的父子关系）器进行加载</li><li>父加载器还是找不到的情况下，才调用自己的加载方法进行类加载。</li></ol><h3 id="双亲委派给我们带来了什么好处"><a href="#双亲委派给我们带来了什么好处" class="headerlink" title="双亲委派给我们带来了什么好处"></a>双亲委派给我们带来了什么好处</h3><ul><li>避免了自己吗的重复加载</li><li>程序更安全，核心的 API 不会被替换</li></ul><h3 id="为什么要打破双亲委派"><a href="#为什么要打破双亲委派" class="headerlink" title="为什么要打破双亲委派"></a>为什么要打破双亲委派</h3><p>从上述中给我们可以得知，所有的类加载最终都会从启动类加载器加载，但是如果我们使用<code>SPI</code>机制去引入一些第三方类库的话，启动类加载器肯定会加载失败，但是</p><blockquote><p>例如<code>java.sql.Driver</code>这种由启动类加载器加载的，所以它的实现类也得是启动类加载器加载</p></blockquote><p>所以我们不得不找一个类加载器让我们的接口和实现类由同一个类加载器加载，那么<code>线程上下文加载器</code>就应运而生，从此打破双亲委派模型，让<code>SPI</code>的接口类和实现类都由同一个类加载器加载，其实就是让</p><p>所以每一次破坏双亲委派都是因为对于类加载的一些特殊要求，历史上有也有这么几次破坏双亲委派的场景：</p><ol><li>由于历史原因，我们可以继承 CLassLoader 类然后重写 loaderClass 方法，从而打破双亲委派，例如：Tomcat 就这样做了</li><li>为了更好的使用<code>SPI</code>，从而引入了线程上下文类加载器，来特意大打破双亲委派</li><li>用户对程序的动态性的极致追求，希望做到代码的热替代，模块的热部署，例如：我也不太熟悉的<code>OSGi</code>(粗略的了解了一下，感觉很有意思，后面会持续去跟进看一下)，就是通过自己的类加载器来实现的，不再是一个树状的双亲委派模型，而是一个网状结构</li><li>JDK9 引入的模块化，这个从源码里面就可以看出，它会在提交给父加载器之前，先判断系统模块的归属问题(后面学习的时候也需要看看)</li></ol><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>总体来说，由于各种各样的原因，我们不得不打破双亲委派模式，但是打破的同时，也要注意代码的安全性，不要盲目的自定义类加载器等等。合理得打破可以提高我们得代码活性，更加灵活。</p><p>相关代码地址:<br><a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> spi </tag>
            
            <tag> java </tag>
            
            <tag> 类加载器 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100dayscode-17 SPI机制浅读:Java SPI</title>
      <link href="/2023/04/15/100dayscode-17/"/>
      <url>/2023/04/15/100dayscode-17/</url>
      
        <content type="html"><![CDATA[<pre><code>在开始了解RPC的时候，我们常常会学会去用到`SpringCloud`和`Dubbo`,那么就必不可少的会去接触到`SPI`，一个熟悉而又陌生的概念，那么今天我们就先来看看这个神秘的`SPI`到底是什么，它能给我们带来什么有意思的东西</code></pre><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><code>SPI</code> 英文全称<code>Service provider interface</code>，从名字我们就可以看的出来，它应该是作用于<code>接口</code>（不一定是 Java 中的那个接口），同时也是提供给对应的供应商的，从字面意思我们可以解读出来，它应该是用作为一些第三方需要接入的实现或者组件预留的一套工具，是一套服务发现机制。</p><h1 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h1><p>其实使用<code>SPI</code>相对来说比理解它更为简单，我们基本上只需要遵循它给到的一些模板，我们就能很好的去利用这样的一个工具。</p><h2 id="固定的-SPI-加载工具类"><a href="#固定的-SPI-加载工具类" class="headerlink" title="固定的 SPI 加载工具类"></a>固定的 SPI 加载工具类</h2><p>JDK 给我们预留了一个用于寻找<code>SPI</code>实现的工具类<code>java.util.ServiceLoader</code>,我们只需要简单的使用它就能够得到我们想要的结果，我们可以看看它的一个方法签名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service,</span></span><br><span class="line"><span class="params">                                        ClassLoader loader)</span></span><br></pre></td></tr></table></figure><h2 id="固定的文件路径"><a href="#固定的文件路径" class="headerlink" title="固定的文件路径"></a>固定的文件路径</h2><p>当我们再进一步去读<code>ServiceLoader</code>的源码的时候，我们就会再开头就看到，它有一个静态变量:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">PREFIX</span> <span class="operator">=</span> <span class="string">&quot;META-INF/services/&quot;</span>;</span><br></pre></td></tr></table></figure><p>我们我们去追寻它的使用的地方的时候会看到这样一段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="type">boolean</span> <span class="title function_">hasNextService</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (nextName != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (configs == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">fullName</span> <span class="operator">=</span> PREFIX + service.getName();</span><br><span class="line">            <span class="keyword">if</span> (loader == <span class="literal">null</span>)</span><br><span class="line">                configs = ClassLoader.getSystemResources(fullName);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            configs = loader.getResources(fullName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            fail(service, <span class="string">&quot;Error locating configuration files&quot;</span>, x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((pending == <span class="literal">null</span>) || !pending.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!configs.hasMoreElements()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pending = parse(service, configs.nextElement());</span><br><span class="line">    &#125;</span><br><span class="line">    nextName = pending.next();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;&#125;</span><br></pre></td></tr></table></figure><p>从这里我们可以进一步确认到，当去寻找<code>SPI</code>具体的实现的时候，我们就会用到这个文件夹，并且再读取文件的时候，使用的是需要寻找的类的全限定名。</p><h1 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h1><p>在看到如何使用后，我们开始大胆的尝试，来利用<code>SPI</code>来发现我们定义的服务</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>首先我们创建一个<code>People</code>接口，来指定我们的需要实现的<code>SPI</code>，并且实现两个他的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Boy</span> <span class="keyword">implements</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I`m boy&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Girl</span> <span class="keyword">implements</span> <span class="title class_">People</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">name</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;I`m girl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后在<code>resource</code>目录下创建对应的目录文件<code>META-INF/services/com.jungle.challenge.spi.interfaces.People</code><br>然后创建一个工厂方法，用来执行<code>SPI</code>的具体实现的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PeopleFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">invoker</span><span class="params">()</span> &#123;</span><br><span class="line">        ServiceLoader&lt;People&gt; loader = ServiceLoader.load(People.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">notFound</span> <span class="operator">=</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (People people : loader) &#123;</span><br><span class="line">            notFound = <span class="literal">false</span>;</span><br><span class="line">            people.name();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (notFound) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">RuntimeException</span>(<span class="string">&quot;Not found any People instant&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="执行验证"><a href="#执行验证" class="headerlink" title="执行验证"></a>执行验证</h2><p>接下来我们直接调用<code>PeopleFactory</code>的<code>invoker</code>方法，可以看到我们报错了：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.RuntimeException: Not found any People instant</span><br><span class="line"></span><br><span class="line">at com.jungle.challenge.spi.core.PeopleFactory.invoker(PeopleFactory.java:18)</span><br></pre></td></tr></table></figure><p>然后我们在<code>com.jungle.challenge.spi.interfaces.People</code>文件中添加我们两个实现类的路径地址</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">com.jungle.challenge.spi.v2.Girl</span><br><span class="line">com.jungle.challenge.spi.v1.Boy</span><br></pre></td></tr></table></figure><p>再次执行</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">I`m girl</span><br><span class="line">I`m boy</span><br></pre></td></tr></table></figure><p>我们确实拿到了我们需要的两个实体类，并执行了他们的<code>name</code>方法</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><p>所以以上就是我们简单的将<code>SPI</code>这个强大的机制使用起来了，当然真实的用法肯定不是在同一个包里面进行使用，这样太过于复杂，何不直接利用简单的多态就行了呢，所以一般都是在一些公共的组件里面预留一些接口给第三方实现的时候使用。一般我们接触到的最多的就是 JDBC 和日志模块，当然在一些框架里面也能经常看到他的身影：</p><ol><li>Spring MVC</li><li>Spring Boot</li><li>Dubbo<br>在这些框架里面还有一些不同的地方，我们在后面再去摸索以下。</li></ol><p>在查阅<code>ServiceLoader</code>的源码的时候，我们发现它利用到了类加载器，并且在默认的方法是先用还是用到的线程上下文的类加载器:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;S&gt; ServiceLoader&lt;S&gt; <span class="title function_">load</span><span class="params">(Class&lt;S&gt; service)</span> &#123;</span><br><span class="line">    <span class="type">ClassLoader</span> <span class="variable">cl</span> <span class="operator">=</span> Thread.currentThread().getContextClassLoader();</span><br><span class="line">    <span class="keyword">return</span> ServiceLoader.load(service, cl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么接下来我们就来说说这个类加载器到底在干些什么事情，为什么我们需要在这里指定。</p><p>相关代码地址:<br><a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> spi </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100DaysCode-Day16 Mybatis 插件:敏感数据脱敏插件（三）</title>
      <link href="/2023/04/14/100dayscode-16/"/>
      <url>/2023/04/14/100dayscode-16/</url>
      
        <content type="html"><![CDATA[<pre><code>上会我们已经将整体的插件模板创建完成了，那么今天我们继续来完成最后的策略实现，以及一些简单的优化</code></pre><h3 id="策略类实现"><a href="#策略类实现" class="headerlink" title="策略类实现"></a>策略类实现</h3><p>首先我们知道，我们定义了一个策略接口<code>DesensitizeStrategy</code>，同时再我们的模板代码，以及注解定义中，我们都看到了策略接口的身影：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DesensitizeStrategy</span> <span class="variable">desensitizeStrategy</span> <span class="operator">=</span> (DesensitizeStrategy) strategy.newInstance();</span><br><span class="line">setMethod.invoke(data, desensitizeStrategy.doDesensitize(value));</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Desensitized &#123;</span><br><span class="line"></span><br><span class="line">    Class&lt;? <span class="keyword">extends</span> <span class="title class_">DesensitizeStrategy</span>&gt; strategy() <span class="keyword">default</span> DefaultDesensitizeStrategy.class;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据注解的定义，只要实现了<code>DesensitizeStrategy</code>的注解接口，那么就能在我们的插件中实例化出来，所以我们现在就来实现一个手机号脱敏策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">PhoneDesensitizeStrategy</span> <span class="keyword">implements</span> <span class="title class_">DesensitizeStrategy</span>&lt;String, String&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doDesensitize</span><span class="params">(String data)</span> &#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们假定所有的手机号都是通过字符串存储的，那么接下来我们使用常用的手机号脱敏方式就是我们常看到了的<code>136****9958</code>这样的一个格式，那么我们这里用一下正则表达式来实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String <span class="title function_">doDesensitize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> data.replaceAll(<span class="string">&quot;(\\d&#123;3&#125;)\\d&#123;4&#125;(\\d+)&quot;</span>, <span class="string">&quot;$1****$2&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们给我们的<code>User</code>的<code>userPhone</code>字段打上对应的策略类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">User</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="meta">@Desensitized(strategy = PhoneDesensitizeStrategy.class)</span></span><br><span class="line">    <span class="keyword">private</span> String userPhone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>允许之后我们得到以下以下结果：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Creating a new SqlSession</span><br><span class="line">SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@e1ce44] was not registered for synchronization because synchronization is not active</span><br><span class="line">JDBC Connection [HikariProxyConnection@31007053 wrapping conn0: url=jdbc:h2:mem:testdb user=SA] will not be managed by Spring</span><br><span class="line">==&gt;  Preparing: select * from user</span><br><span class="line">==&gt; Parameters:</span><br><span class="line">&lt;==    Columns: ID, USER_NAME, USER_PHONE</span><br><span class="line">&lt;==        Row: 1, user1, 110112113114</span><br><span class="line">&lt;==        Row: 2, user2, 110112113114</span><br><span class="line">&lt;==        Row: 3, user3, 110112113114</span><br><span class="line">&lt;==        Row: 4, user4, 110112113114</span><br><span class="line">&lt;==        Row: 5, user5, 110112113114</span><br><span class="line">&lt;==        Row: 6, user6, 110112113114</span><br><span class="line">&lt;==      Total: 6</span><br><span class="line">Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@e1ce44]</span><br><span class="line">User(id=1, userName=user1, userPhone=110****13114)</span><br><span class="line">User(id=2, userName=user2, userPhone=110****13114)</span><br><span class="line">User(id=3, userName=user3, userPhone=110****13114)</span><br><span class="line">User(id=4, userName=user4, userPhone=110****13114)</span><br><span class="line">User(id=5, userName=user5, userPhone=110****13114)</span><br><span class="line">User(id=6, userName=user6, userPhone=110****13114)</span><br></pre></td></tr></table></figure><p>可以看到，虽然我们从数据库里面查到的是明文，但是我们最终得到的数据是通过了我们脱敏的数据</p><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><p>目前我们的插件很轻易的就能发现由很多可以优化的点</p><h4 id="1-策略类不需要每次都创建，我们可以使用全局单例类来处理"><a href="#1-策略类不需要每次都创建，我们可以使用全局单例类来处理" class="headerlink" title="1. 策略类不需要每次都创建，我们可以使用全局单例类来处理"></a>1. 策略类不需要每次都创建，我们可以使用全局单例类来处理</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">DesensitizeStrategy</span> <span class="variable">desensitizeStrategy</span> <span class="operator">=</span> STRATEGY_MAP.computeIfAbsent(annotation.strategy(), (key) -&gt; &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (DesensitizeStrategy) key.newInstance();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DefaultDesensitizeStrategy</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们可以使用一个<code>STRATEGY_MAP</code>来装载策略类，避免每次都需要重新创建</p><h4 id="2-对于类的反射操作也是一样，不需要每次都使用反射的方式去获取"><a href="#2-对于类的反射操作也是一样，不需要每次都使用反射的方式去获取" class="headerlink" title="2.对于类的反射操作也是一样，不需要每次都使用反射的方式去获取"></a>2.对于类的反射操作也是一样，不需要每次都使用反射的方式去获取</h4><p>处理方式同上方一样，这里就不再赘述了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>通过以上方式，我们就创建了一个可让用户自己实现脱敏策略的 Mybatis 插件,当然还有很多不足和值得优化的地方，后续有时间，我们再继续进行调整</p><p>相关代码地址:<br><a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> mybatis </tag>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100DaysCode-Day15 Mybatis 插件:敏感数据脱敏插件（二）</title>
      <link href="/2023/04/13/100dayscode-15/"/>
      <url>/2023/04/13/100dayscode-15/</url>
      
        <content type="html"><![CDATA[<pre><code>上次我们已经定义好了插件的一些大致实现方案，那么接下来我们就将上诉方案进行整合，来完成我们的数据脱敏插件</code></pre><h2 id="整合"><a href="#整合" class="headerlink" title="整合"></a>整合</h2><h3 id="第一步将集合类型和对象类型分开处理"><a href="#第一步将集合类型和对象类型分开处理" class="headerlink" title="第一步将集合类型和对象类型分开处理"></a>第一步将集合类型和对象类型分开处理</h3><p>由于我们使用查询接口的时候，有时候会使用<code>List</code>等集合来接收数据，也有时候用单一的对象类型去接收数据，所以我们在处理返回值的时候需要分别对这两种情况进行处理，所以我们就需要将他们分开来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">    <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">    Class&lt;?&gt; resultClass = proceed.getClass();</span><br><span class="line">    <span class="keyword">if</span> (Collection.class.isAssignableFrom(resultClass)) &#123;</span><br><span class="line">        Collection&lt;?&gt; result = (Collection&lt;?&gt;) proceed;</span><br><span class="line">        <span class="keyword">if</span> (result.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">        Class&lt;?&gt; resultMapClazz = result.stream().findFirst().get().getClass();</span><br><span class="line">        result.forEach(data -&gt; doDesensitize(resultMapClazz, data));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        doDesensitize(resultClass, proceed);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> proceed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由以上方法，我们就可以将集合类型的数据和对象类型的数据分别处理，同时对于集合类型内的数据我们其实，处理方式和对象类型数据处理方式一样，所以我们只需要使用<code>forEach</code>方法对其进行迭代处理即可</p><h3 id="抽象处理方法"><a href="#抽象处理方法" class="headerlink" title="抽象处理方法"></a>抽象处理方法</h3><p>通过上一个步骤，我们发现其实集合类型的处理和对象类型的处理已经被我们抽象成一致的方式了，所以我们只需要定义好对应的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doDesensitize</span><span class="params">(Class&lt;?&gt; resultMapClazz, Object data)</span></span><br></pre></td></tr></table></figure><p>接下来我们就是逐步去实现该方法即可</p><h4 id="获取当前对象需要处理的字段"><a href="#获取当前对象需要处理的字段" class="headerlink" title="获取当前对象需要处理的字段"></a>获取当前对象需要处理的字段</h4><p>由于我们在对接收对象进行定义的时候已经对数据进行了标记，所以我们只需要通过获取字段身上的注解，即可判断当前的字段需不需要进行脱敏处理，首先我们这里需要用到一些反射的知识，所以我们提前做一些工具类来方便后期的使用，如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ClassUtil</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Method <span class="title function_">getMethod</span><span class="params">(Class&lt;?&gt; clazz, MethodTYpe type, Field field)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> field.getName();</span><br><span class="line">        name = name.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + name.substring(<span class="number">1</span>);</span><br><span class="line">        name = type.name().toLowerCase() + name;</span><br><span class="line">        <span class="keyword">return</span> type.equals(MethodTYpe.GET) ?</span><br><span class="line">                clazz.getDeclaredMethod(name) :</span><br><span class="line">                clazz.getDeclaredMethod(name, field.getType());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> List&lt;Field&gt; <span class="title function_">filterFieldList</span><span class="params">(List&lt;Field&gt; fieldList, Class&lt;?&gt; annotationType)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> fieldList.stream()</span><br><span class="line">                .filter(field -&gt; Arrays.stream(field.getAnnotations())</span><br><span class="line">                        .anyMatch(annotation -&gt; annotation.annotationType().equals(annotationType)))</span><br><span class="line">                .collect(Collectors.toList());</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">MethodTYpe</span> &#123;</span><br><span class="line">        GET, SET</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们很方便就可以得到我们想要的需要脱敏的字段：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Field&gt; desensitizedFields = ClassUtil</span><br><span class="line">        .filterFieldList(Arrays.asList(resultMapClazz.getDeclaredFields()), Desensitized.class);</span><br></pre></td></tr></table></figure><h4 id="获取当前字段的-GET-x2F-SET-方法"><a href="#获取当前字段的-GET-x2F-SET-方法" class="headerlink" title="获取当前字段的 GET&#x2F;SET 方法"></a>获取当前字段的 GET&#x2F;SET 方法</h4><p>同理我们运用我们的工具类也可以很轻易的得到：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Method</span> <span class="variable">getMethod</span> <span class="operator">=</span> ClassUtil.getMethod(resultMapClazz, ClassUtil.MethodTYpe.GET, field);</span><br><span class="line"><span class="type">Object</span> <span class="variable">invoke</span> <span class="operator">=</span> getMethod.invoke(data);</span><br><span class="line"><span class="keyword">if</span> (invoke == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">Method</span> <span class="variable">setMethod</span> <span class="operator">=</span> ClassUtil.getMethod(resultMapClazz, ClassUtil.MethodTYpe.SET, field);</span><br></pre></td></tr></table></figure><p>当然我们也可以看出，如果获取到的数据是<code>null</code>的话，那么我们就没必要进行处理了（当然我们也可以自动帮他填充成一个默认对象，但是这个一般有风险，不建议使用）</p><h4 id="获取策略类"><a href="#获取策略类" class="headerlink" title="获取策略类"></a>获取策略类</h4><p>当所有的基础方法都准备完毕之后，我们还记得，我们保留了一个策略类在我们的注解中，那么我们同样需要从注解中拿到对应的策略类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Desensitized</span> <span class="variable">annotation</span> <span class="operator">=</span> field.getAnnotation(Desensitized.class);</span><br><span class="line">Class&lt;?&gt; strategy = annotation.strategy();</span><br><span class="line"><span class="type">DesensitizeStrategy</span> <span class="variable">desensitizeStrategy</span> <span class="operator">=</span> (DesensitizeStrategy) strategy.newInstance();</span><br></pre></td></tr></table></figure><p>至此我们将整串代码组合在一起，那么就形成了我们所需要的模板代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">doDesensitize</span><span class="params">(Class&lt;?&gt; resultMapClazz, Object data)</span> &#123;</span><br><span class="line">    List&lt;Field&gt; desensitizedFields = ClassUtil</span><br><span class="line">            .filterFieldList(Arrays.asList(resultMapClazz.getDeclaredFields()), Desensitized.class);</span><br><span class="line">    <span class="keyword">if</span> (desensitizedFields.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Field field : desensitizedFields) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">getMethod</span> <span class="operator">=</span> ClassUtil.getMethod(resultMapClazz, ClassUtil.MethodTYpe.GET, field);</span><br><span class="line">            <span class="type">Object</span> <span class="variable">value</span> <span class="operator">=</span> getMethod.invoke(data);</span><br><span class="line">            <span class="keyword">if</span> (value == <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">Method</span> <span class="variable">setMethod</span> <span class="operator">=</span> ClassUtil.getMethod(resultMapClazz, ClassUtil.MethodTYpe.SET, field);</span><br><span class="line"></span><br><span class="line">            <span class="type">Desensitized</span> <span class="variable">annotation</span> <span class="operator">=</span> field.getAnnotation(Desensitized.class);</span><br><span class="line">            Class&lt;?&gt; strategy = annotation.strategy();</span><br><span class="line">            <span class="type">DesensitizeStrategy</span> <span class="variable">desensitizeStrategy</span> <span class="operator">=</span> (DesensitizeStrategy) strategy.newInstance();</span><br><span class="line">            setMethod.invoke(data, desensitizeStrategy.doDesensitize(value));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剩下的就是留给我们的策略类的具体实现了，那么下次我们再去实现我们自己的策略类，来完善我们当前的这个插件</p><p>相关代码地址:<br><a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> mybatis </tag>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100DaysCode-Day14 Mybatis 插件:敏感数据脱敏插件（一）</title>
      <link href="/2023/04/12/100dayscode-14/"/>
      <url>/2023/04/12/100dayscode-14/</url>
      
        <content type="html"><![CDATA[<pre><code>为了巩固之前对Mybatis插件的学习，同时也想到了一个之前经常遇到的问题，数据库的数据需要脱敏（如用户手机号，密码等），那么今天我们就来一个创建一个Mybatis的数据脱敏插件</code></pre><h2 id="数据脱敏插件"><a href="#数据脱敏插件" class="headerlink" title="数据脱敏插件"></a>数据脱敏插件</h2><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>首先通过对需求的分析，我们可以轻易得知以下几个要点</p><ol><li>我们需要对查询的返回值进行数据脱敏</li><li>脱敏的数据需要被标记，不然插件无法得知哪些数据是需要脱敏的</li><li>每个数据的脱敏策略可能不一样，所以在标记的时候或许需要预设好脱敏的策略</li></ol><h3 id="方案"><a href="#方案" class="headerlink" title="方案"></a>方案</h3><h4 id="对查询返回值进行脱敏"><a href="#对查询返回值进行脱敏" class="headerlink" title="对查询返回值进行脱敏"></a>对查询返回值进行脱敏</h4><blockquote><p>那么我们结合上次所学到的知识，我们可以确定到我们需要用到的插入点是 ResultSetHandler</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">ResultSetHandler</span> &#123;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; List&lt;E&gt; <span class="title function_">handleResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line"></span><br><span class="line">  &lt;E&gt; Cursor&lt;E&gt; <span class="title function_">handleCursorResultSets</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span> <span class="title function_">handleOutputParameters</span><span class="params">(CallableStatement cs)</span> <span class="keyword">throws</span> SQLException;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么很自然的可以看到有一个<code>handleResultSets</code>方法，那么我们就对这个方法进行拦截。那么就得到了以下的拦截注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;@Signature(</span></span><br><span class="line"><span class="meta">        type = ResultSetHandler.class,</span></span><br><span class="line"><span class="meta">        method = &quot;handleResultSets&quot;,</span></span><br><span class="line"><span class="meta">        args = &#123;Statement.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;)</span></span><br></pre></td></tr></table></figure><h4 id="标记数据"><a href="#标记数据" class="headerlink" title="标记数据"></a>标记数据</h4><p>标记数据我们最常用的就是自定义注解了，所以这里我们就创建一个自定义注解，用来标记我们需要脱敏的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Retention(RetentionPolicy.RUNTIME)</span></span><br><span class="line"><span class="meta">@Target(&#123;ElementType.FIELD&#125;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Desensitized &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多种脱敏策略"><a href="#多种脱敏策略" class="headerlink" title="多种脱敏策略"></a>多种脱敏策略</h4><p>我们可以借助在我们创建的自定义注解<code>Desensitized</code>添加策略字段，来标记使用哪一种策略，我们这里创建一个策略接口，并提供一个默认实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DesensitizeStrategy</span>&lt;T, R&gt; &#123;</span><br><span class="line"></span><br><span class="line">    R <span class="title function_">doDesensitize</span><span class="params">(T data)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DefaultDesensitizeStrategy</span> <span class="keyword">implements</span> <span class="title class_">DesensitizeStrategy</span>&lt;String, String&gt; &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">doDesensitize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK,方案已经定好了，那么下一次我们来将整体的方案进行整合和调整，来实现我们自己 DIY 的一个数据脱敏插件</p><p>相关代码地址:<br><a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> mybatis </tag>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100DaysCode-Day13 Mybatis 插件入门</title>
      <link href="/2023/04/11/100dayscode-13/"/>
      <url>/2023/04/11/100dayscode-13/</url>
      
        <content type="html"><![CDATA[<blockquote><p>最近在做项目的时候，由于需要为实体类生成对应的雪花 ID，但是又不可能每次在创建实例的时候再去<br>调用方法，所以，想到了能不能借助于 Myabtis 的插件来实现，因为在之前的工作过程中也用到过它的<br>分页插件<code>PageHelper</code>,所以接下来将要学习以下 Myabtis 的插件开发</p></blockquote><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Myabtis 的插件允许我们在映射语句执行的过程中的某一个点进行拦截，并且提供了以下几个拦截点（具体的更多的信息，后面再去深读一下源码）</p><ul><li>Executor</li><li>ParameterHandler</li><li>ResultSetHandler</li><li>StatmentHandler<br>所以它主要也是提供了一个拦截器<code>Intercaptor</code>接口来供我们使用，以方便接入我们实现的插件，同时需要配合<code>@intercepts</code>注解和<code>@Signature</code>注解使用</li></ul><p>首先们根据官方的说明简易的创建一个插件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Intercepts(&#123;@Signature(</span></span><br><span class="line"><span class="meta">        type = Executor.class,</span></span><br><span class="line"><span class="meta">        method = &quot;query&quot;,</span></span><br><span class="line"><span class="meta">        args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;</span></span><br><span class="line"><span class="meta">)&#125;)</span></span><br><span class="line"><span class="meta">@Slf4j</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UsedTimeAnalysePlugin</span> <span class="keyword">implements</span> <span class="title class_">Interceptor</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">intercept</span><span class="params">(Invocation invocation)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        log.info(<span class="string">&quot;Pre executor&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">proceed</span> <span class="operator">=</span> invocation.proceed();</span><br><span class="line">        log.info(<span class="string">&quot;After executor&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> proceed;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面我们再来说明一下每个地方到底是怎么回事</p><h3 id="Intercepts"><a href="#Intercepts" class="headerlink" title="@Intercepts"></a>@Intercepts</h3><p>这里是为了指定哪些方法需要被当前我们声明的拦截器拦截到，具体的拦截信息是在内部的<code>@Signature</code>来定义的，这里相当于是一个标识注解</p><h3 id="Signature"><a href="#Signature" class="headerlink" title="@Signature"></a>@Signature</h3><p>这里是声明具体哪个方法需要被拦截到，当前例子的说明如下：</p><h4 id="type"><a href="#type" class="headerlink" title="type"></a>type</h4><p>这里是指代的我们上面所说的拦截点，这里我们选择的是<code>Executor</code></p><h4 id="method"><a href="#method" class="headerlink" title="method"></a>method</h4><p>这里是指代的我们拦截点上的某个方法的名称，这里我们选择的是拦截<code>Executor</code>的<code>query</code>方法</p><h4 id="args"><a href="#args" class="headerlink" title="args"></a>args</h4><p>这里可能会比较疑惑，为什么我们这里会填写这四个类呢？我们需要去找到<code>Executor</code>的<code>query</code>方法的声明</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;E&gt; List&lt;E&gt; <span class="title function_">query</span><span class="params">(MappedStatement ms, Object parameter, RowBounds rowBounds, ResultHandler resultHandler)</span> <span class="keyword">throws</span> SQLException;</span><br></pre></td></tr></table></figure><p>可以看到我们这里的所填写的四个类信息，就是对应的方法声明的四个入参的类信息</p><p>所以综上所述，<code>@Signature</code>其实就是去指明我们要拦截的方法到底是哪一个</p><h3 id="UsedTimeAnalysePlugin"><a href="#UsedTimeAnalysePlugin" class="headerlink" title="UsedTimeAnalysePlugin"></a>UsedTimeAnalysePlugin</h3><p>这里就是我们通过实现 Mybatis 提供的接口来实现的<code>自定义的Plugin</code>，最简易的方法就是去实现他的<code>intercept</code>方法，像在这里我们就是简单的在语句允许的前后，打印了一些信息通过执行我们可以得到以下结果：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">2023-04-11 22:45:00.028  INFO 17896 --- [           main] c.j.c.plugins.UsedTimeAnalysePlugin      : Pre executor</span><br><span class="line">JDBC Connection [HikariProxyConnection@4491252 wrapping conn0: url=jdbc:h2:mem:testdb user=SA] will not be managed by Spring</span><br><span class="line">==&gt;  Preparing: select * from user</span><br><span class="line">==&gt; Parameters:</span><br><span class="line">&lt;==    Columns: ID, USER_NAME</span><br><span class="line">&lt;==        Row: 1, user1</span><br><span class="line">&lt;==        Row: 2, user2</span><br><span class="line">&lt;==        Row: 3, user3</span><br><span class="line">&lt;==        Row: 4, user4</span><br><span class="line">&lt;==        Row: 5, user5</span><br><span class="line">&lt;==        Row: 6, user6</span><br><span class="line">&lt;==      Total: 6</span><br><span class="line">2023-04-11 22:45:42.161  INFO 17896 --- [           main] c.j.c.plugins.UsedTimeAnalysePlugin      : After executor</span><br></pre></td></tr></table></figure><p>所以一个简易的 Mybatis Plugin 就这样被我们实现了。<br>在这里我们其实需要注意的是，他的实现很简单，但是我们需要分析到我们到底想要做些什么，才能找到对应的方法去给他装配插件，最后才能达到我们想要的效果，所以如果要去实现 Mybatis 的插件，我们就得了解到，我们到底需要去拦截哪个拦截点的哪个方法。</p><p>相关代码地址:<br><a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> mybatis </tag>
            
            <tag> 插件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100DaysCode-Day12 再看RxJava:转化Flowable（三）</title>
      <link href="/2023/04/10/100dayscode-12/"/>
      <url>/2023/04/10/100dayscode-12/</url>
      
        <content type="html"><![CDATA[<pre><code>在上次的实例中，我们已经使用过了`retry`,那么我们今天来看一下这个操作到底在帮助我们做些什么事情</code></pre><p>我们很轻易的就能创造一个错误</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateFlowable</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; retryFlowable = Flowable.range(<span class="number">0</span>, <span class="number">10</span>).map(data -&gt; <span class="number">1000</span> / data).retry(<span class="number">3</span>);</span><br><span class="line">    retryFlowable.subscribe(<span class="keyword">new</span> <span class="title class_">ConsoleSubscribe</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>于是我们就得到了以下的打印结果：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread:【main】 在 2023-04-10T15:07:24.186Z 开启注册消费！</span><br><span class="line">Thread:【main】 在 2023-04-10T15:07:24.196Z 发现了异常错误！java.lang.ArithmeticException: / by zero</span><br></pre></td></tr></table></figure><p>根绝这个结果我们看到，一旦发生了错误，整个<code>Flowable</code>就停止了，并且程序貌似并没有像我们预期的方式重试三次，这个是为什么呢？<br>经过对<code>Flowable</code>进一步研究，我们猜想是不是并没有进入到我们预期的<code>onNext</code>方法中，是不是与我们的<code>map</code>操作有关，所以我们在<code>map</code>操作之前加入一个监听方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateFlowable</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; retryFlowable = Flowable.range(<span class="number">0</span>, <span class="number">10</span>)</span><br><span class="line">            .doOnEach(data -&gt; System.out.println(<span class="string">&quot;Thread:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】 在 &quot;</span> + Instant</span><br><span class="line">                    .now() + <span class="string">&quot; 消费了 data【&quot;</span> + data.getValue() + <span class="string">&quot;】&quot;</span>))</span><br><span class="line">            .map(data -&gt; <span class="number">1000</span> / data).retry(<span class="number">3</span>);</span><br><span class="line">    retryFlowable.subscribe(<span class="keyword">new</span> <span class="title class_">ConsoleSubscribe</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们又得到了以下结果：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Thread:【main】 在 2023-04-10T15:11:24.690Z 开启注册消费！</span><br><span class="line">Thread:【main】 在 2023-04-10T15:11:24.699Z 消费了 data【0】</span><br><span class="line">Thread:【main】 在 2023-04-10T15:11:24.700Z 消费了 data【0】</span><br><span class="line">Thread:【main】 在 2023-04-10T15:11:24.700Z 消费了 data【0】</span><br><span class="line">Thread:【main】 在 2023-04-10T15:11:24.700Z 消费了 data【0】</span><br><span class="line">Thread:【main】 在 2023-04-10T15:11:24.701Z 发现了异常错误！java.lang.ArithmeticException: / by zero</span><br></pre></td></tr></table></figure><p>很明显的可以看得到，<code>RxJava</code>在我们自己执行错误的情况下，确实帮助我们重试了三次，而且重试点应该是从操作的头部开始，并且尾部的接收方法<code>onNext</code>并不会捕获到执行情况，所以在使用的时候需要特别注意。<br>其次并不是<code>retry</code>中断了<code>Flowale</code>中的数据传递，是因为错误被<code>onError</code>捕获到了，所以才会推出当前的数据传递。</p><p>相关代码地址:<br><a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> rxjava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100DaysCode-Day11 再看RxJava:实践:JClient（二）</title>
      <link href="/2023/04/09/100dayscode-11/"/>
      <url>/2023/04/09/100dayscode-11/</url>
      
        <content type="html"><![CDATA[<h2 id="实现：-失败重试"><a href="#实现：-失败重试" class="headerlink" title="实现： 失败重试"></a>实现： 失败重试</h2><pre><code>接上次的案例，我们需要构建一个失败请求的后的重试方法。</code></pre><p>很简单我们能想到的方法声明：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Single&lt;?&gt; retryableDoServer(Server server, Long times)</span><br></pre></td></tr></table></figure><p>他的具体实现也很简单，因为我们能够在<code>RxJava</code>中找到一个我们还没有学习过的转换方法<code>retry</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Single&lt;?&gt; retryableDoServer(Server server, Long times) &#123;</span><br><span class="line">    <span class="keyword">return</span> server.service(client).retry(times);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此他的重试方式我们就完成了，那么接下来我们对这个方法进行测试。</p><pre><code>我们会使用一个OPEN Api来帮助我们模拟网络请求</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Server <span class="title function_">makeService</span><span class="params">(Integer time)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> client -&gt; client</span><br><span class="line">            .getAbs(<span class="string">&quot;http://httpstat.us/200?sleep=&quot;</span> + time)</span><br><span class="line">            .rxSend()</span><br><span class="line">            .doOnSuccess(data -&gt; System.out.println(<span class="string">&quot; &quot;</span> + time + <span class="string">&quot; is finish at&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>()))</span><br><span class="line">            .timeout(<span class="number">900</span>, TimeUnit.MILLISECONDS)</span><br><span class="line">            .doOnError(data -&gt; System.err.println(Thread.currentThread().getName() + <span class="string">&quot;:&quot;</span> + data))</span><br><span class="line">            .map(data -&gt; data.bodyAsString() + <span class="string">&quot; with &quot;</span> + time + <span class="string">&quot; at&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在里面加入了一个超时，当我们请求等待的时间超过阈值的时候，这个请求就会失败，我们先试一下如果我们不超过等待时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testRetry</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">JClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JClient</span>();</span><br><span class="line">    Single&lt;?&gt; single = client.retryableDoServer(makeService(<span class="number">500</span>), <span class="number">3L</span>);</span><br><span class="line">    <span class="type">Subscription</span> <span class="variable">subscribe</span> <span class="operator">=</span> single</span><br><span class="line">            .subscribe(System.out::println, System.err::println);</span><br><span class="line">    <span class="keyword">while</span> (!subscribe.isUnsubscribed()) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会得到以下结果</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RxComputationScheduler-1:java.util.concurrent.TimeoutException</span><br><span class="line">RxComputationScheduler-2:java.util.concurrent.TimeoutException</span><br><span class="line"> 500 is finish atMon Apr 10 22:50:23 CST 2023</span><br><span class="line">200 OK with 500 atMon Apr 10 22:50:23 CST 2023</span><br></pre></td></tr></table></figure><p>可以看到，虽然我们的请求延迟并没有超过等待时间，但是它还是给我们报错了，并且帮我们重试了 2 次后成功了，这样变相的证明了我们的重试的成功的，至于报错信息，有可能是因为我们用的这个 OPEN API 不太稳定的原因。那么当我们把请求等待时间改变成 2000ms：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Single&lt;?&gt; single = client.retryableDoServer(makeService(<span class="number">2000</span>), <span class="number">3L</span>);</span><br></pre></td></tr></table></figure><p>我们会得到以下结果</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RxComputationScheduler-1:java.util.concurrent.TimeoutException</span><br><span class="line">RxComputationScheduler-2:java.util.concurrent.TimeoutException</span><br><span class="line">RxComputationScheduler-3:java.util.concurrent.TimeoutException</span><br><span class="line">RxComputationScheduler-4:java.util.concurrent.TimeoutException</span><br><span class="line">java.util.concurrent.TimeoutException</span><br></pre></td></tr></table></figure><p>可以看到<code>RxJava</code>除开我们自己请求的一次以外，确实帮我们重试了 3 次，符合我们的预期，并且在第三次重试失败之后，结束了当前的信息消费。<br>至此我们的一个多功能的 Client 就完成了，后期如果还有其他的实现，或者补充修改的地方我们会继续持续更新。</p><p>相关代码地址:<br><a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a><br><a href="https://github.com/dgjungleP/Bakend_demo/tree/main/jclient">JClient</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> rxjava </tag>
            
            <tag> 实践 </tag>
            
            <tag> jclient </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100DaysCode-Day10 再看RxJava:实践:JClient（一）</title>
      <link href="/2023/04/08/100dayscode-10/"/>
      <url>/2023/04/08/100dayscode-10/</url>
      
        <content type="html"><![CDATA[<pre><code>经过前面的学习，我们已经了解到一些`RxJava`的使用方式，今天我们在这里借助一个小小的案例来综合使用一下我们学到的知识，首先这里我们会使用到`Vert.x`的`RxJava`实现</code></pre><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><p>我们需要创建一个 Http 请求工具，能够满足我们的一些特殊的处理方式</p><ul><li>并行访问</li><li>失败重试</li></ul><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><h3 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h3><p>这里涉及到<code>Http</code>请求工具所以我们借用一下<code>Vert.x</code>的<code>RxJava</code>实现帮助我们简化我们的实现细节。</p><h4 id="MAVEN"><a href="#MAVEN" class="headerlink" title="MAVEN"></a>MAVEN</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.reactivex.rxjava3<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>rxjava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.vertx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>vertx-web-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>io.vertx<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>vertx-rx-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><blockquote><p>Server.java 模拟单个的请求访问</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Server</span> &#123;</span><br><span class="line"></span><br><span class="line">    Single&lt;?&gt; service(WebClient client);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>JClient.java 对请求进行封装</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">JClient</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> WebClient client;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">JClient</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">Vertx</span> <span class="variable">vertx</span> <span class="operator">=</span> Vertx.vertx();</span><br><span class="line">        <span class="built_in">this</span>.client = WebClient.create(vertx);</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现：并行访问"><a href="#实现：并行访问" class="headerlink" title="实现：并行访问"></a>实现：并行访问</h2><p>首先我们需要了解到，我们是需要将多个请求访问并行执行,并且每个请求都会得到相应的返回值，那么我们很轻易的想到，我们有两个可以使用的创建方式<code>merge</code>和<code>zip</code>。所以我们可以很简单的就想到我们的方法声明应该是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Single&lt;List&lt;?&gt;&gt; multiDoServer(Server... servers);</span><br><span class="line"></span><br></pre></td></tr></table></figure><pre><code> 这里所用到`Single`是另一种`RxJava`的创建方式，使用场景和`Flowable`不一样但是，大体的思路一样地， 而且我们用到的`WebClient`使用的就是这个，所以我们先暂时用这个创建方式来示意。</code></pre><p>所以我们能够很轻松的想到，接下来我们需要将每一个<code>server</code>转化成对应的<code>RxJava</code>能够聚合的实体即可，所以我们的完整实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Single&lt;List&lt;?&gt;&gt; multiDoServer(Server... servers) &#123;</span><br><span class="line">    List&lt;? <span class="keyword">extends</span> <span class="title class_">Single</span>&lt;?&gt;&gt; list = Arrays.stream(servers).map(server -&gt; server.service(client))</span><br><span class="line">            .collect(Collectors.toList());</span><br><span class="line">    <span class="keyword">return</span> Single.zip(list, Arrays::asList);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><pre><code> 我们会使用一个OPEN Api来帮助我们模拟网络请求</code></pre><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Server <span class="title function_">makeService</span><span class="params">(Integer time)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> client -&gt; client.getAbs(<span class="string">&quot;http://httpstat.us/200?sleep=&quot;</span> + time)</span><br><span class="line">            .rxSend()</span><br><span class="line">            .doOnSuccess(data -&gt; System.out.println(<span class="string">&quot; &quot;</span> + time + <span class="string">&quot; is finish at&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>()))</span><br><span class="line">            .map(data -&gt; data.bodyAsString() + <span class="string">&quot; with &quot;</span> + time + <span class="string">&quot; at&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>那么接下来我们通过一个简单的测试，来试一下我们创建的并行请求具体使用情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException &#123;</span><br><span class="line">    <span class="type">JClient</span> <span class="variable">client</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">JClient</span>();</span><br><span class="line">    <span class="type">long</span> <span class="variable">start</span> <span class="operator">=</span> System.currentTimeMillis();</span><br><span class="line">    Single&lt;List&lt;?&gt;&gt; server = client</span><br><span class="line">            .multiDoServer(makeService(<span class="number">1000</span>), makeService(<span class="number">2000</span>), makeService(<span class="number">1000</span>), makeService(<span class="number">1000</span>), makeService(<span class="number">3000</span>));</span><br><span class="line">    <span class="type">Subscription</span> <span class="variable">subscribe</span> <span class="operator">=</span> server.subscribe();</span><br><span class="line">    <span class="keyword">while</span> (!subscribe.isUnsubscribed()) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println(<span class="string">&quot;Used:&quot;</span> + (System.currentTimeMillis() - start) + <span class="string">&quot; ms&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们得到以下结果：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> 1000 is finish atMon Apr 10 22:31:13 CST 2023</span><br><span class="line"> 1000 is finish atMon Apr 10 22:31:13 CST 2023</span><br><span class="line"> 1000 is finish atMon Apr 10 22:31:13 CST 2023</span><br><span class="line"> 2000 is finish atMon Apr 10 22:31:14 CST 2023</span><br><span class="line"> 3000 is finish atMon Apr 10 22:31:15 CST 2023</span><br><span class="line">Used:4613 ms</span><br></pre></td></tr></table></figure><p>我们可以看到，它并不是按照我们添加 servise 的顺序取请求的，而且总共消耗了 4.6s，小于五个请求的延迟总和 8s,，其中有一些时间消耗属于<code>网络I/O</code>和<code>Vert.x</code>内部的调度，所以总和来看，我们确实简单的实现了一个并行请求的 Client，可能还有很多需要改进的地方。</p><p>相关代码地址:<br><a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a><br><a href="https://github.com/dgjungleP/Bakend_demo/tree/main/jclient">JClient</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> rxjava </tag>
            
            <tag> 实践 </tag>
            
            <tag> jclient </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100DaysCode-Day09 再看RxJava:转化Flowable（二）</title>
      <link href="/2023/04/07/100dayscode-9/"/>
      <url>/2023/04/07/100dayscode-9/</url>
      
        <content type="html"><![CDATA[<pre><code>在之前的操作中，我们经常需要为每一个Flowable进行模拟延迟的时候，都使用了一个`map`的操作符，那么今天，我们就来看一下这个map到底可以为我们做些什么。</code></pre><h3 id="map"><a href="#map" class="headerlink" title="map"></a>map</h3><p>如果大家都使用过 Java8 提供的<code>Stream</code>的话，那么多以这个 map 就很熟悉了，它就是可以让我们在对流的处理过程中，可以将流中的数据转化成我们所需要的数据，那么<code>RxJava</code>提供的 map 呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateFlowable</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; mapFlowable = Flowable.range(<span class="number">1</span>, <span class="number">10</span>).map(data -&gt; <span class="number">2</span> * data);</span><br><span class="line">    mapFlowable.subscribe(<span class="keyword">new</span> <span class="title class_">ConsoleSubscribe</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到结果，确实如我们所想，它确实可以将我们的数据进行一些处理：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread:【main】 在 2023-04-07T14:37:58.044Z 开启注册消费！</span><br><span class="line">Thread:【main】 在 2023-04-07T14:37:58.044Z 消费了 data【2】</span><br><span class="line">Thread:【main】 在 2023-04-07T14:37:58.044Z 消费了 data【4】</span><br><span class="line">Thread:【main】 在 2023-04-07T14:37:58.044Z 消费了 data【6】</span><br><span class="line">Thread:【main】 在 2023-04-07T14:37:58.044Z 消费了 data【8】</span><br><span class="line">Thread:【main】 在 2023-04-07T14:37:58.044Z 消费了 data【10】</span><br><span class="line">Thread:【main】 在 2023-04-07T14:37:58.044Z 消费了 data【12】</span><br><span class="line">Thread:【main】 在 2023-04-07T14:37:58.044Z 消费了 data【14】</span><br><span class="line">Thread:【main】 在 2023-04-07T14:37:58.044Z 消费了 data【16】</span><br><span class="line">Thread:【main】 在 2023-04-07T14:37:58.044Z 消费了 data【18】</span><br><span class="line">Thread:【main】 在 2023-04-07T14:37:58.044Z 消费了 data【20】</span><br><span class="line">Thread:【main】 在 2023-04-07T14:37:58.044Z 完成了消费</span><br></pre></td></tr></table></figure><p>那么讲到了<code>map</code>肯定也会联想到<code>flatmap</code>,那么<code>RxJava</code>中的<code>flatmap</code> 是不是也和<code>Stream</code>提供的功能类似呢</p><h3 id="flatmap"><a href="#flatmap" class="headerlink" title="flatmap"></a>flatmap</h3><p>从方法签名中我们可以看到，它确实类似于<code>Stream</code>,是将当前的数据转化成另一个<code>Flowable</code>并展开使用</p><ul><li><code>public final &lt;@NonNull R&gt; Flowable&lt;R&gt; flatMap(@NonNull Function&lt;? super T, @NonNull ? extends Publisher&lt;? extends R&gt;&gt; mapper)</code><br>我们尝试着使用一下:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateFlowable2</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; mapFlowable = Flowable.range(<span class="number">1</span>, <span class="number">4</span>).flatMap(data -&gt; Flowable.range(<span class="number">1</span>, data));</span><br><span class="line">    mapFlowable.subscribe(<span class="keyword">new</span> <span class="title class_">ConsoleSubscribe</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到了我们预期的结果：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread:【main】 在 2023-04-07T14:43:47.394Z 开启注册消费！</span><br><span class="line">Thread:【main】 在 2023-04-07T14:43:47.409Z 消费了 data【1】</span><br><span class="line">Thread:【main】 在 2023-04-07T14:43:47.409Z 消费了 data【1】</span><br><span class="line">Thread:【main】 在 2023-04-07T14:43:47.409Z 消费了 data【2】</span><br><span class="line">Thread:【main】 在 2023-04-07T14:43:47.409Z 消费了 data【1】</span><br><span class="line">Thread:【main】 在 2023-04-07T14:43:47.409Z 消费了 data【2】</span><br><span class="line">Thread:【main】 在 2023-04-07T14:43:47.409Z 消费了 data【3】</span><br><span class="line">Thread:【main】 在 2023-04-07T14:43:47.409Z 消费了 data【1】</span><br><span class="line">Thread:【main】 在 2023-04-07T14:43:47.409Z 消费了 data【2】</span><br><span class="line">Thread:【main】 在 2023-04-07T14:43:47.409Z 消费了 data【3】</span><br><span class="line">Thread:【main】 在 2023-04-07T14:43:47.409Z 消费了 data【4】</span><br><span class="line">Thread:【main】 在 2023-04-07T14:43:47.409Z 完成了消费</span><br></pre></td></tr></table></figure><p>但是<code>Flowable</code>中的<code>flatmap</code>提供了更多其他的重载方法，可以说更加丰富，我们在后续的使用中遇到了，再去细细斟酌</p><p>相关代码地址:<br><a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> rxjava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100DaysCode-Day08 再看RxJava:转化Flowable（一）</title>
      <link href="/2023/04/06/100dayscode-8/"/>
      <url>/2023/04/06/100dayscode-8/</url>
      
        <content type="html"><![CDATA[<pre><code>在学习异步和并行处理之前，由于业务原因，我同时又遇到了一个问题，当我有很多数据要进行处理时，由于数据量过大，内存可能无法支持到这么多数据，这个时候我需要对数据进行分组批处理，那么这个时候`RxJava`能够怎么样轻易的帮助我们完成这项工作呢</code></pre><h3 id="buffer"><a href="#buffer" class="headerlink" title="buffer"></a>buffer</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateFlowable</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; rangeFlowable = Flowable.range(<span class="number">1</span>, <span class="number">100000</span>);</span><br><span class="line">    rangeFlowable.subscribe(<span class="keyword">new</span> <span class="title class_">ConsoleSubscribe</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们假设现在的一个场景，我们有大概 10w 条数需要批处理，但是如果一次性全部都在内存中处理，我们的内存可能就支撑不住，从而导致堆溢出等情况发生，那么为了缓解这一压力，我们能够想到的就是，希望能够将这 10w 条数据拆分成可能大的批次，然后进行分批次处理，我们可以用到各种方式对这批数据进行分批，那利用<code>RxJava</code>，我们可以如何轻松的做到呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateFlowable</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; rangeFlowable = Flowable.range(<span class="number">1</span>, <span class="number">10</span>);</span><br><span class="line">    Flowable&lt;List&lt;Integer&gt;&gt; bufferFlowable = rangeFlowable.buffer(<span class="number">5</span>);</span><br><span class="line">    bufferFlowable.subscribe(<span class="keyword">new</span> <span class="title class_">ConsoleSubscribe</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到就这样简单的一句(由于篇幅原因，我们将数据量改小了)，我们就轻松的办到了</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread:【main】 在 2023-04-07T14:13:38.900Z 开启注册消费！</span><br><span class="line">Thread:【main】 在 2023-04-07T14:13:38.916Z 消费了 data【[1, 2, 3, 4, 5]】</span><br><span class="line">Thread:【main】 在 2023-04-07T14:13:38.916Z 消费了 data【[6, 7, 8, 9, 10]】</span><br><span class="line">Thread:【main】 在 2023-04-07T14:13:38.916Z 完成了消费</span><br></pre></td></tr></table></figure><p>何以很明确的看到，确实达到了分组的效果，确实很方便。除了简单的分组以外，<code>buffer</code>还给我们提供了<code>时间窗口</code>的功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateFlowable2</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; rangeFlowable = Flowable.range(<span class="number">1</span>, <span class="number">10</span>).map(data -&gt; &#123;</span><br><span class="line">        TimeUnit.MILLISECONDS.sleep(<span class="number">200</span>);</span><br><span class="line">        <span class="keyword">return</span> data;</span><br><span class="line">    &#125;).subscribeOn(Schedulers.io());</span><br><span class="line">    Flowable&lt;List&lt;Integer&gt;&gt; bufferFlowable = rangeFlowable.buffer(<span class="number">500</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">    bufferFlowable.subscribe(<span class="keyword">new</span> <span class="title class_">ConsoleSubscribe</span>());</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时我们得到了由时间窗口分批的结果</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread:【main】 在 2023-04-07T14:27:06.453Z 开启注册消费！</span><br><span class="line">Thread:【RxComputationThreadPool-1】 在 2023-04-07T14:27:06.976Z 消费了 data【[1, 2]】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 在 2023-04-07T14:27:07.478Z 消费了 data【[3, 4, 5]】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 在 2023-04-07T14:27:07.974Z 消费了 data【[6, 7]】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 在 2023-04-07T14:27:08.480Z 消费了 data【[8, 9]】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 在 2023-04-07T14:27:08.528Z 消费了 data【[10]】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 在 2023-04-07T14:27:08.528Z 完成了消费</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>所以这里我们可以看到，针对于一些大流量或者大批量的数据需要进行分批处理的时候，我们可以分方便的适用<code>RxJava</code>的<code>buffer</code>功能，当然除了执行分批大小和时间窗口以外，他们还能随意组合，以及更多高级功能可以适用，这个后面我们在使用到的时候在进行说明吧。</p><p>相关代码地址:<br><a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> rxjava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100DaysCode-Day07 再看RxJava:创建Flowable（四）</title>
      <link href="/2023/04/05/100dayscode-7/"/>
      <url>/2023/04/05/100dayscode-7/</url>
      
        <content type="html"><![CDATA[<pre><code>上一次我浅用了以下merge方法，它确实可以把多个`Flowable`聚合在一起，但是却不能满足我们预设的要求，将多个耗时操作异步执行，并且，并利用其结果去组装我们想要的下游数据，那么接下来，我们再看一下另一个能够组合`Flowable`的创建方式</code></pre><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>我们可以看到最简单易用的<code>zip</code>的方法签名如下</p><ul><li><code>public static &lt;@NonNull T, @NonNull R&gt; Flowable&lt;R&gt; zip(@NonNull Iterable&lt;@NonNull ? extends Publisher&lt;? extends T&gt;&gt; sources, @NonNull Function&lt;? super Object[], ? extends R&gt; zipper)</code><br>可以很明显的看到，我们不仅要将元数据放置进来，还需要提供一个<code>zipper</code>的方法，对放入的元数据进行处理</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateFlowable</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Publisher&lt;Integer&gt;&gt; publisherList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        publisherList.add(getDelayFlowable(i, <span class="number">0</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    Flowable&lt;Integer&gt; zipFlowable = Flowable</span><br><span class="line">            .zip(publisherList, (dataList) -&gt; Arrays.stream(dataList).mapToInt(data -&gt; &#123;</span><br><span class="line">                <span class="keyword">if</span> (data <span class="keyword">instanceof</span> Number) &#123;</span><br><span class="line">                    <span class="keyword">return</span> ((Number) data).intValue();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;).sum());</span><br><span class="line">    zipFlowable.subscribe(<span class="keyword">new</span> <span class="title class_">ConsoleSubscribe</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上例子，我们拿到了结果</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread:【main】 在 2023-04-07T13:54:26.106Z 开启注册消费！</span><br><span class="line">Thread:【main】 在 2023-04-07T13:54:26.106Z 消费了 data【45】</span><br><span class="line">Thread:【main】 在 2023-04-07T13:54:26.106Z 完成了消费</span><br></pre></td></tr></table></figure><p>确实它帮我们将 0-9 之间的数的总和进行的求解，那么我们可以看到<code>zip</code>可以让我们对多个<code>Flowable</code>的数据进行求解，然后同过<code>zipper</code>函数，让我们得到我们想要的数据，这种针对于有时我们需要<code>向多方拿取数据，然后整合数据</code>的场景中我们可以适用 zip 来帮助我们。<br>那么接下一个问题，所有入参的<code>Flowable</code>是并行执行的吗？为了验证这一点，我们给每个<code>Flowable</code>增加一个 1 秒的延迟，如果是并行执行的，那么我们将在 1-2 秒内拿到我们想要的结果。</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread:【main】 在 2023-04-07T13:59:15.050Z 开启注册消费！</span><br><span class="line">Thread:【main】 在 2023-04-07T13:59:25.145Z 消费了 data【45】</span><br><span class="line">Thread:【main】 在 2023-04-07T13:59:25.145Z 完成了消费</span><br></pre></td></tr></table></figure><p>结果我们看到，我们足足等了 10 秒，也就是所有的<code>Flowable</code>并不是并行执行的，而且<code>zip</code>需要等待到所有的<code>Flowable</code>准备就绪之后才能执行<code>zipper</code>函数。<br>所以接下来我们如何让每一个<code>Flowable</code>并行执行呢？接下来我们将继续取探索。</p><p>相关代码地址:<br><a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> rxjava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100DaysCode-Day06 再看RxJava:创建Flowable（三）</title>
      <link href="/2023/04/04/100dayscode-6/"/>
      <url>/2023/04/04/100dayscode-6/</url>
      
        <content type="html"><![CDATA[<pre><code>之前我们的创建都是围绕着一个`Flowable`来进行的，那么我们可以将多个`Flowable`组合在一起么，例如我们日常工作中的一种场景，当我们要去组装一条数据的时候，由于历史或者设计原因，我们不得不进行多次网络调用或者计较耗时的操作，但是每个操作基本上都是可以异步执行的，那么对于这种情况`RxJava`又能怎么样帮助我们简单的来处理呢？</code></pre><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>从方法声明中我们看到有一个叫做<code>merge</code>的静态方法，他的入参就是我们在学习<code>subscribe</code>的时候看到的<code>Publisher</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;<span class="meta">@NonNull</span> T&gt; Flowable&lt;T&gt; <span class="title function_">merge</span><span class="params">(<span class="meta">@NonNull</span> Iterable&lt;<span class="meta">@NonNull</span> ? extends Publisher&lt;? extends T&gt;&gt; sources)</span></span><br></pre></td></tr></table></figure><p>而在观察我们 Flowable 的类声明的时候我们可以看到以下关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Flowable</span>&lt;<span class="meta">@NonNull</span> T&gt; <span class="keyword">implements</span> <span class="title class_">Publisher</span>&lt;T&gt;</span><br></pre></td></tr></table></figure><p>所以，merge 方法可以将我们的多个 Flowable 聚合在一起，至于它有什么效果，我们先动手试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateFlowable</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Publisher&lt;Integer&gt;&gt; publisherList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        publisherList.add(Flowable.just(i));</span><br><span class="line">    &#125;</span><br><span class="line">    Flowable&lt;Integer&gt; mergeFlowable = Flowable.merge(publisherList);</span><br><span class="line">    mergeFlowable.subscribe(<span class="keyword">new</span> <span class="title class_">ConsoleSubscribe</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们得到了以下结果：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread:【main】 在 2023-04-04T14:42:53.590Z 开启注册消费！</span><br><span class="line">Thread:【main】 在 2023-04-04T14:42:53.605Z 消费了 data【0】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:42:53.605Z 消费了 data【1】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:42:53.605Z 消费了 data【2】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:42:53.605Z 消费了 data【3】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:42:53.605Z 消费了 data【4】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:42:53.605Z 消费了 data【5】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:42:53.605Z 消费了 data【6】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:42:53.605Z 消费了 data【7】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:42:53.605Z 消费了 data【8】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:42:53.605Z 消费了 data【9】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:42:53.605Z 完成了消费</span><br></pre></td></tr></table></figure><p>可以看出 merge 看起来是将所有的数据，进行了有机的聚合，甚至于还是有顺序的，那么我们稍微再做一点尝试，为么个<code>Flowable</code>增加一点随机的延迟，这里会用到<code>map</code>操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateFlowable</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Publisher&lt;Integer&gt;&gt; publisherList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        publisherList.add(Flowable.just(i).map(data -&gt; &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep((<span class="type">long</span>) (<span class="number">200</span> + Math.random() * <span class="number">1000</span>));</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    Flowable&lt;Integer&gt; mergeFlowable = Flowable.merge(publisherList);</span><br><span class="line">    mergeFlowable.subscribe(<span class="keyword">new</span> <span class="title class_">ConsoleSubscribe</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread:【main】 在 2023-04-04T14:49:24.360Z 开启注册消费！</span><br><span class="line">Thread:【main】 在 2023-04-04T14:49:24.840Z 消费了 data【0】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:49:25.165Z 消费了 data【1】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:49:25.487Z 消费了 data【2】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:49:26.028Z 消费了 data【3】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:49:26.371Z 消费了 data【4】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:49:27.210Z 消费了 data【5】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:49:28.257Z 消费了 data【6】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:49:28.702Z 消费了 data【7】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:49:28.904Z 消费了 data【8】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:49:29.696Z 消费了 data【9】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:49:29.696Z 完成了消费</span><br></pre></td></tr></table></figure><p>从结果中我们看得出来，它确实是按照我们添加<code>Flowable</code>的顺序进行的消息消费，纵使每个消息都有各自的延迟，它还是会等待着前一个消息消费完成，才进行后面的消息消费，这样是不符合我们的预期的，我们希望的是这 10 个消息能够尽可能快地在同一时间并行消费，那么我们有没有什么办法做到这一点呢？</p><pre><code>答案是没有，对于`merge`的定义，其实只是将所有`Publisher`中所需要传递的数据扁平化，供给给下游使用。</code></pre><p>所以它适用的场景，是对于多方<code>同源数据</code>或者<code>异构数据</code>进行合并处理，以满足下游的消费。、<br>所以我们还得继续跟踪<code>Flowable</code>的下一种创建方式</p><p>相关代码地址:<br><a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> rxjava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100DaysCode-Day05 再看RxJava:创建Flowable（二）</title>
      <link href="/2023/04/03/100dayscode-5/"/>
      <url>/2023/04/03/100dayscode-5/</url>
      
        <content type="html"><![CDATA[<pre><code>上次我们制作了简单的`心跳包`，那除了`心跳`以外我们还能做些什么呢。在对创建方法的探索中，我们又发现了一个带有类似`interval`方法签名的一个方法</code></pre><h3 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h3><p>其最简单的方法签名为：</p><ul><li><code>public static Flowable&lt;Long&gt; timer(long delay, @NonNull TimeUnit unit)</code><br>从其方法的说明文档中，我们可以看到它的声明，是可以在延迟一定的时间后，发送一个<code>0L</code>供给下游消费</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateFlowable</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Long&gt; flowable = Flowable.timer(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    flowable.subscribe(<span class="keyword">new</span> <span class="title class_">ConsoleSubscribe</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们同样去简单的使用一下，我们只得到了一句注册成功的打印：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread:【main】 在 2023-04-03T13:09:49.346Z 开启注册消费！</span><br></pre></td></tr></table></figure><p>那么加上死循环之后，我们再次运行：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread:【main】 在 2023-04-03T13:11:26.225Z 开启注册消费！</span><br><span class="line">Thread:【RxComputationThreadPool-1】 在 2023-04-03T13:11:36.236Z 消费了 data【0】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 在 2023-04-03T13:11:36.238Z 完成了消费</span><br></pre></td></tr></table></figure><p>我们得到了以上结果，那么这种结合上一次的<code>interval</code>我们貌似得到了前端同学经常使用的两个工具，一个<code>定时任务</code>和一个<code>延迟任务</code>，那么有了这两个方便的工具我们能用来做一些什么有趣的东西呢？</p><p>相关代码地址:<br><a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> rxjava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100DaysCode-Day04 再看RxJava:创建Flowable（一）</title>
      <link href="/2023/04/02/100dayscode-4/"/>
      <url>/2023/04/02/100dayscode-4/</url>
      
        <content type="html"><![CDATA[<pre><code>在探索能够用已学习的知识能够用来做些什么东西的时候，本来想着来制作一个`心跳器`的，却发现还没有很好的办法去创建一个`心跳`，本着对于心跳的理解，所以心跳信号应该是用`Flowable`这种消息发布体来进行，提供所以，又得去探索一下关于`Flowable`的一些操作知识。</code></pre><blockquote><p>在第一次创建<code>Flowable</code>的时候看到他有很多的静态方法，那么就浅看一下有没有适合<code>心跳</code>的创建方式</p></blockquote><h3 id="interval"><a href="#interval" class="headerlink" title="interval"></a>interval</h3><p>我们找到他看上去最简单的方法签名：</p><ul><li><code>public static Flowable&lt;Long&gt; interval(long period, @NonNull TimeUnit unit)</code><br>结合到方法的说明文档。我们知道这个方法可以让我们创建一个不断输出有序数字的发射器。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateFlowable</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Long&gt; intervalFlowable = Flowable.interval(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    intervalFlowable.subscribe(<span class="keyword">new</span> <span class="title class_">ConsoleSubscribe</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们运行这段代码，只得到了一串打印信息（<code>ConsoleSubscribe</code>是我编写的一个会打印出模板信息<code>Thead - Time - Data</code>的<code>Subscribe</code>实现）:</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread:【main】 在 2023-04-03T12:54:23.243Z 开启注册消费！</span><br></pre></td></tr></table></figure><p>所以可以看到我们确实注册成功了，但是并没有执行消费。我们猜测是不是因为消息的传递不是在<code>main</code>线程执行的，所以我们添加一个死循环，来监控一下，最后得到了我们预取的打印数据：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread:【main】 在 2023-04-03T12:57:13.927Z 开启注册消费！</span><br><span class="line">Thread:【RxComputationThreadPool-1】 在 2023-04-03T12:57:14.937Z 消费了 data【0】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 在 2023-04-03T12:57:15.942Z 消费了 data【1】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 在 2023-04-03T12:57:16.951Z 消费了 data【2】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 在 2023-04-03T12:57:17.942Z 消费了 data【3】</span><br></pre></td></tr></table></figure><p>确实是在一个线程池中进行了数据消费。那么自此我们的一个微型的<code>心跳</code>就制作完成了，目前只会进行简单的打印（取决于你对<code>Subscribe</code>的具体实现）</p><p>相关代码地址:<br><a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> rxjava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100DaysCode-Day03 再看RxJava:Scheduler</title>
      <link href="/2023/04/01/100dayscode-3/"/>
      <url>/2023/04/01/100dayscode-3/</url>
      
        <content type="html"><![CDATA[<p>经过昨天的学习，我们认识到了可以如何去消费我们<code>Flowable</code>创建出来的消息，那么现在存在一个疑问，那么它是在那个线程去执行的呢。我们用一个新的方式<code>range</code>去创建一个例子尝试一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSchedule</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; flowable = Flowable.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Disposable</span> <span class="variable">subscribe</span> <span class="operator">=</span> flowable</span><br><span class="line">            .subscribe(data -&gt; System.out</span><br><span class="line">                    .println(<span class="string">&quot;Thread:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】 消费了 data【&quot;</span> + data + <span class="string">&quot;】&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread:【main】 消费了 data【0】</span><br><span class="line">Thread:【main】 消费了 data【1】</span><br><span class="line">Thread:【main】 消费了 data【2】</span><br><span class="line">Thread:【main】 消费了 data【3】</span><br><span class="line">Thread:【main】 消费了 data【4】</span><br><span class="line">Thread:【main】 消费了 data【5】</span><br><span class="line">Thread:【main】 消费了 data【6】</span><br><span class="line">Thread:【main】 消费了 data【7】</span><br><span class="line">Thread:【main】 消费了 data【8】</span><br><span class="line">Thread:【main】 消费了 data【9】</span><br></pre></td></tr></table></figure><p>那么如果我们要让他<code>异步执行</code>该怎么办呢？经过对 API 的排查我们发现了几个特别的方法签名：</p><blockquote><ol><li><code>public final Flowable&lt;T&gt; subscribeOn(@NonNull Scheduler scheduler)</code></li><li><code>public final Flowable&lt;T&gt; subscribeOn(@NonNull Scheduler scheduler, boolean requestOn)</code></li><li><code>public final Flowable&lt;T&gt; unsubscribeOn(@NonNull Scheduler scheduler)</code></li></ol></blockquote><p>从这个<code>Scheduler</code>的文档里面我们发现这样一句话：<br>You can get various standard, RxJava-specific instances of this class via the static methods of the io.reactivex.rxjava3.schedulers.Schedulers utility class.</p><p>那么在不太熟悉的情况下，我们就按照官方文档的建议我们去看一下这个<code>Schedulers</code>里面携带了什么标准内容给我们使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Scheduler IO;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Scheduler COMPUTATION;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Scheduler SINGLE;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Scheduler TRAMPOLINE;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Scheduler NEW_THREAD;</span><br></pre></td></tr></table></figure><p>我们分别来使用一下看一下效果</p><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScheduleIo</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; flowable = Flowable.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    flowable = flowable</span><br><span class="line">            .subscribeOn(Schedulers.io());</span><br><span class="line">    <span class="type">Disposable</span> <span class="variable">subscribe</span> <span class="operator">=</span> flowable</span><br><span class="line">            .subscribe(data -&gt; System.out</span><br><span class="line">                    .println(<span class="string">&quot;Thread:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】 消费了 data【&quot;</span> + data + <span class="string">&quot;】&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【0】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【1】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【2】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【3】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【4】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【5】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【6】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【7】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【8】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【9】</span><br></pre></td></tr></table></figure><h4 id="使用的结论"><a href="#使用的结论" class="headerlink" title="使用的结论"></a>使用的结论</h4><p>建立一单独的线程来处理数据，看起来时在背后建立了一个线程池，那么我们看一下官方文档是怎么介绍的<br>Returns a default, shared Scheduler instance intended for IO-bound work.<br>This can be used for asynchronously performing blocking IO.<br>The implementation is backed by a pool of single-threaded ScheduledExecutorService instances that will try to reuse previously started instances used by the worker returned by Scheduler</p><h3 id="COMPUTATION"><a href="#COMPUTATION" class="headerlink" title="COMPUTATION"></a>COMPUTATION</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScheduleIo</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; flowable = Flowable.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    flowable = flowable</span><br><span class="line">            .subscribeOn(Schedulers.io());</span><br><span class="line">    <span class="type">Disposable</span> <span class="variable">subscribe</span> <span class="operator">=</span> flowable</span><br><span class="line">            .subscribe(data -&gt; System.out</span><br><span class="line">                    .println(<span class="string">&quot;Thread:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】 消费了 data【&quot;</span> + data + <span class="string">&quot;】&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【0】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【1】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【2】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【3】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【4】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【5】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【6】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【7】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【8】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【9】</span><br></pre></td></tr></table></figure><h4 id="使用的结论-1"><a href="#使用的结论-1" class="headerlink" title="使用的结论"></a>使用的结论</h4><p>建立一单独的线程来处理数据，看起来时在背后建立了一个线程池，那么我们看一下官方文档是怎么介绍的<br>Returns a default, shared Scheduler instance intended for computational work.<br>This can be used for event-loops, processing callbacks and other computational work.<br>It is not recommended to perform blocking, IO-bound work on this scheduler. Use io() instead.<br>从说明里面看，如果执行过程中没有阻塞行为的话，可以使用这个类型</p><h3 id="SINGLE"><a href="#SINGLE" class="headerlink" title="SINGLE"></a>SINGLE</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScheduleComputation</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; flowable = Flowable.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    flowable = flowable</span><br><span class="line">            .subscribeOn(Schedulers.computation());</span><br><span class="line">    <span class="type">Disposable</span> <span class="variable">subscribe</span> <span class="operator">=</span> flowable</span><br><span class="line">            .subscribe(data -&gt; System.out</span><br><span class="line">                    .println(<span class="string">&quot;Thread:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】 消费了 data【&quot;</span> + data + <span class="string">&quot;】&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h4><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【0】</span><br><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【1】</span><br><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【2】</span><br><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【3】</span><br><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【4】</span><br><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【5】</span><br><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【6】</span><br><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【7】</span><br><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【8】</span><br><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【9】</span><br></pre></td></tr></table></figure><h4 id="使用的结论-2"><a href="#使用的结论-2" class="headerlink" title="使用的结论"></a>使用的结论</h4><p>建立一单独的线程来处理数据，看起来时在背后建立了一个线程池，那么我们看一下官方文档是怎么介绍的<br>Returns a default, shared, single-thread-backed Scheduler instance for work requiring strongly-sequential execution on the same background thread.</p><h3 id="TRAMPOLINE"><a href="#TRAMPOLINE" class="headerlink" title="TRAMPOLINE"></a>TRAMPOLINE</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScheduleComputation</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; flowable = Flowable.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    flowable = flowable</span><br><span class="line">            .subscribeOn(Schedulers.computation());</span><br><span class="line">    <span class="type">Disposable</span> <span class="variable">subscribe</span> <span class="operator">=</span> flowable</span><br><span class="line">            .subscribe(data -&gt; System.out</span><br><span class="line">                    .println(<span class="string">&quot;Thread:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】 消费了 data【&quot;</span> + data + <span class="string">&quot;】&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h4><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread:【main】 消费了 data【0】</span><br><span class="line">Thread:【main】 消费了 data【1】</span><br><span class="line">Thread:【main】 消费了 data【2】</span><br><span class="line">Thread:【main】 消费了 data【3】</span><br><span class="line">Thread:【main】 消费了 data【4】</span><br><span class="line">Thread:【main】 消费了 data【5】</span><br><span class="line">Thread:【main】 消费了 data【6】</span><br><span class="line">Thread:【main】 消费了 data【7】</span><br><span class="line">Thread:【main】 消费了 data【8】</span><br><span class="line">Thread:【main】 消费了 data【9】</span><br></pre></td></tr></table></figure><h4 id="使用的结论-3"><a href="#使用的结论-3" class="headerlink" title="使用的结论"></a>使用的结论</h4><p>从结果来看，它还是使用了当前线程处理，因为现在的执行线程是 Main 线程，所以我们拿到的也是 Main 线程<br>The default implementation’s Scheduler.scheduleDirect(Runnable) methods execute the tasks on the current thread without any queueing and the timed overloads use blocking sleep as well</p><h3 id="NEW-THREAD"><a href="#NEW-THREAD" class="headerlink" title="NEW_THREAD"></a>NEW_THREAD</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScheduleComputation</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; flowable = Flowable.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    flowable = flowable</span><br><span class="line">            .subscribeOn(Schedulers.computation());</span><br><span class="line">    <span class="type">Disposable</span> <span class="variable">subscribe</span> <span class="operator">=</span> flowable</span><br><span class="line">            .subscribe(data -&gt; System.out</span><br><span class="line">                    .println(<span class="string">&quot;Thread:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】 消费了 data【&quot;</span> + data + <span class="string">&quot;】&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果-4"><a href="#结果-4" class="headerlink" title="结果"></a>结果</h4><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【0】</span><br><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【1】</span><br><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【2】</span><br><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【3】</span><br><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【4】</span><br><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【5】</span><br><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【6】</span><br><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【7】</span><br><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【8】</span><br><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【9】</span><br></pre></td></tr></table></figure><h4 id="使用的结论-4"><a href="#使用的结论-4" class="headerlink" title="使用的结论"></a>使用的结论</h4><p>建立一单独的线程来处理数据，看起来时在背后建立了一个线程池，那么我们看一下官方文档是怎么介绍的<br>Returns a default, shared Scheduler instance that creates a new Thread for each unit of work.</p><p>综上俩看，基本上每一个特定的标准都是创建了一个线程池来办这个事情，那么现实真的是不是呢，我们后面在真正的使用的时候，我们再去追一下源码看看具体情况，但是现在有一个问题，如果我自己有一个线程池，我能不能使用我自己的线程池呢，从方法签名中我们有找到几个特定的方法：</p><blockquote><ol><li><code>public static Scheduler from(@NonNull Executor executor)</code></li><li><code>public static Scheduler from(@NonNull Executor executor, boolean interruptibleWorker)</code></li><li><code>public static Scheduler from(@NonNull Executor executor, boolean interruptibleWorker, boolean fair</code></li></ol></blockquote><p>从这里我们看到，确实我们能够使用自己的线程池，所以接下来我们看一下我们应该如何去使用我们现在学习过的知识点。</p><p>相关代码地址:<br><a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> rxjava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100DaysCode-Day02 再看RxJava:Subscribe</title>
      <link href="/2023/03/31/100dayscode-2/"/>
      <url>/2023/03/31/100dayscode-2/</url>
      
        <content type="html"><![CDATA[<p>在昨天的使用我们，我们是用了最简单的 RxJava 的模型，在这里我们回顾一下我们是如何订阅了消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Disposable</span> <span class="variable">subscribe</span> <span class="operator">=</span> flowable.subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p>这里使用了 subscibe 方法的一个重载方法，其实它总共有其中不同的声明</p><blockquote><ol><li><code>public final Disposable subscribe()</code></li><li><code>public final Disposable subscribe(@NonNull Consumer&lt;? super T&gt; onNext)</code></li><li><code>public final Disposable subscribe(@NonNull Consumer&lt;? super T&gt; onNext, @NonNull Consumer&lt;? super Throwable&gt; onError)</code></li><li><code>public final Disposable subscribe(@NonNull Consumer&lt;? super T&gt; onNext, @NonNull Consumer&lt;? super Throwable&gt; onError,@NonNull Action onComplete)</code></li><li><code>public final Disposable subscribe(@NonNull Consumer&lt;? super T&gt; onNext,@NonNull Consumer&lt;? super Throwable&gt; onError,@NonNull Action onComplete,@NonNull DisposableContainer container)</code></li><li><code>public final void subscribe(@NonNull Subscriber&lt;? super T&gt; subscriber)</code></li><li><code>public final void subscribe(@NonNull FlowableSubscriber&lt;? super T&gt; subscriber)</code></li></ol></blockquote><p>其中我们主要来看一下序号<code>6</code>的方法重载，其他的方法重载，是为了方便取使用而做的一些简化。<br>从签名中我们就注意到了一个对象<code>Subscriber&lt;? super T&gt;</code>，那么它的组成部分到底是什么样的，我们来看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Subscriber&lt;Integer&gt; subscriber = <span class="keyword">new</span> <span class="title class_">Subscriber</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Subscription s)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(Integer o)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从接口的方法签名上，我们就可以明确的看到，这里有四个接口方法需要我们实现，那么就可以<code>Flowable</code>的消息进行订阅了。如果要达到昨天效果，我们只需要取实现对应的<code>onNext</code>和<code>onSubscribe</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Flowable&lt;Integer&gt; flowable = Flowable.just(<span class="number">1</span>);</span><br><span class="line">Subscriber&lt;Integer&gt; subscriber = <span class="keyword">new</span> <span class="title class_">Subscriber</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Subscription s)</span> &#123;</span><br><span class="line">      s.request(Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(Integer o)</span> &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">flowable.subscribe(subscriber);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一定要注意<code>onSubscribe</code>方法，按照接口的说明，如果没有对<code>Subscription</code>进行 request 操作的话，那么其实<code>Publisher</code>并不会发送消息，这里为什么用<code>s.request(Long.MAX_VALUE)</code>,其实当你去看对应的重载发放的时候，你就会发现当我们用其他的重载方法的时候，他会去做这样一个组装，帮我们构造一个<code>LambdaSubscriber</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LambdaSubscriber&lt;T&gt; ls = <span class="keyword">new</span> <span class="title class_">LambdaSubscriber</span>&lt;&gt;(onNext, onError, onComplete, FlowableInternalHelper.RequestMax.INSTANCE);</span><br></pre></td></tr></table></figure><p>那么这里就看得到有一个<code>单例对象FlowableInternalHelper.RequestMax.INSTANCE</code>,那我们再看一下它指代的是什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RequestMax</span> <span class="keyword">implements</span> <span class="title class_">Consumer</span>&lt;Subscription&gt; &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Subscription t)</span> &#123;</span><br><span class="line">        t.request(Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这就是为什么我们也用这个的原因，那我们可不可以用其他的数值来代替呢？，当我们把他换成任意一个数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Subscription s)</span> &#123;</span><br><span class="line">    s.request(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会发现，它在现在的上下文上，确实也得到了我们的预期，但是如果我们将上下文做一个处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flowable&lt;Integer&gt; flowable = Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>那么这个时候，你就会发现它打印了 1 之后就再也没有其他的打印了。所以我们再去看一下 <code>Subscription</code>的<code>request(long)</code>方法的说明文档，我们就会发现，它说明了这里是用来限制到底能够最多拿到<code>Publisher</code>发送的多少个消息，所以我们在这里可以大胆的假设它的使用场景：</p><ul><li>定量的心跳包发送</li><li>请求限流<br>那么剩下的<code>onNext</code>方法、<code>onError</code>方法、<code>onComplete</code>方法我们就见名知意了，分别是用于处理每一次获取到消息、发生异常时的处理、消息完全接收完毕之后的处理。到后续我们需要的时候再回过头来继续看看，他们有没有什么可以利用的点。</li></ul><p>相关代码地址:<br><a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> rxjava </tag>
            
            <tag> 小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100DaysCode-Day01 再看RxJava:Hello Flowable</title>
      <link href="/2023/03/30/100dayscode-1/"/>
      <url>/2023/03/30/100dayscode-1/</url>
      
        <content type="html"><![CDATA[<p>在我的工作中，我使用最多的场景就是用 RxJava 帮助我处理异步任务的问题，所以对于 RxJava 的起步我应该是从<code>Flowable</code>开始切入的。那么这里就浅讲一下<code>Flowable</code>的使用方式（总的来说 RxJava 的几乎所有的<code>被观察者</code>都是这样创建的）。</p><blockquote><p>它可能不对，但是我确实是这样入坑的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createFlowable</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; flowable = Flowable.just(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了这样的一个简单的包含一个可被监控元素的 Flowable 的被监听者已经创建好了，当运行代码的时候，会发现什么也没有发生，是因为只有被监听者准备好了，他还没有被监听。所以我们就需要让他被监听起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createFlowable</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; flowable = Flowable.just(<span class="number">1</span>);</span><br><span class="line">    flowable.subscribe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样运行之后发现，还是什么变化也没有，是因为监听者并没有做任何的事情，那么就需要给他定制一个当监听到对应的数据的时候的一个行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createFlowable</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; flowable = Flowable.just(<span class="number">1</span>);</span><br><span class="line">    <span class="type">Disposable</span> <span class="variable">subscribe</span> <span class="operator">=</span> flowable.subscribe(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样执行后，我们就会发现，我们声明了他只需要简单的打印一下拿到的数据就可以了，运行之后我们也拿到了对应的结果</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>至此一个简易的 RxJava 的模型就已经完成了，他可以说是 RxJava 的全部内容，也可以说是冰山一角，剩下的中间操作、监听者的配置以及<code>Disposable</code>则是接下来需要深入理解的东西。</p><p>代码地址:<br><a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> rxjava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开始</title>
      <link href="/2023/03/28/test-layout/"/>
      <url>/2023/03/28/test-layout/</url>
      
        <content type="html"><![CDATA[<p>现在 从这里开始启程吧</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活随记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
