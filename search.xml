<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>100DaysCode-Day04 再看RxJava:创建Flowable（三）</title>
      <link href="/2023/04/04/100dayscode-6/"/>
      <url>/2023/04/04/100dayscode-6/</url>
      
        <content type="html"><![CDATA[<pre><code>之前我们的创建都是围绕着一个`Flowable`来进行的，那么我们可以将多个`Flowable`组合在一起么，例如我们日常工作中的一种场景，当我们要去组装一条数据的时候，由于历史或者设计原因，我们不得不进行多次网络调用或者计较耗时的操作，但是每个操作基本上都是可以异步执行的，那么对于这种情况`RxJava`又能怎么样帮助我们简单的来处理呢？</code></pre><h3 id="merge"><a href="#merge" class="headerlink" title="merge"></a>merge</h3><p>从方法声明中我们看到有一个叫做<code>merge</code>的静态方法，他的入参就是我们在学习<code>subscribe</code>的时候看到的<code>Publisher</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;<span class="meta">@NonNull</span> T&gt; Flowable&lt;T&gt; <span class="title function_">merge</span><span class="params">(<span class="meta">@NonNull</span> Iterable&lt;<span class="meta">@NonNull</span> ? extends Publisher&lt;? extends T&gt;&gt; sources)</span></span><br></pre></td></tr></table></figure><p>而在观察我们 Flowable 的类声明的时候我们可以看到以下关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">class</span> <span class="title class_">Flowable</span>&lt;<span class="meta">@NonNull</span> T&gt; <span class="keyword">implements</span> <span class="title class_">Publisher</span>&lt;T&gt;</span><br></pre></td></tr></table></figure><p>所以，merge 方法可以将我们的多个 Flowable 聚合在一起，至于它有什么效果，我们先动手试一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateFlowable</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Publisher&lt;Integer&gt;&gt; publisherList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        publisherList.add(Flowable.just(i));</span><br><span class="line">    &#125;</span><br><span class="line">    Flowable&lt;Integer&gt; mergeFlowable = Flowable.merge(publisherList);</span><br><span class="line">    mergeFlowable.subscribe(<span class="keyword">new</span> <span class="title class_">ConsoleSubscribe</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们得到了以下结果：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread:【main】 在 2023-04-04T14:42:53.590Z 开启注册消费！</span><br><span class="line">Thread:【main】 在 2023-04-04T14:42:53.605Z 消费了 data【0】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:42:53.605Z 消费了 data【1】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:42:53.605Z 消费了 data【2】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:42:53.605Z 消费了 data【3】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:42:53.605Z 消费了 data【4】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:42:53.605Z 消费了 data【5】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:42:53.605Z 消费了 data【6】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:42:53.605Z 消费了 data【7】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:42:53.605Z 消费了 data【8】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:42:53.605Z 消费了 data【9】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:42:53.605Z 完成了消费</span><br></pre></td></tr></table></figure><p>可以看出 merge 看起来是将所有的数据，进行了有机的聚合，甚至于还是有顺序的，那么我们稍微再做一点尝试，为么个<code>Flowable</code>增加一点随机的延迟，这里会用到<code>map</code>操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateFlowable</span><span class="params">()</span> &#123;</span><br><span class="line">    List&lt;Publisher&lt;Integer&gt;&gt; publisherList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">        publisherList.add(Flowable.just(i).map(data -&gt; &#123;</span><br><span class="line">            TimeUnit.MILLISECONDS.sleep((<span class="type">long</span>) (<span class="number">200</span> + Math.random() * <span class="number">1000</span>));</span><br><span class="line">            <span class="keyword">return</span> data;</span><br><span class="line">        &#125;));</span><br><span class="line">    &#125;</span><br><span class="line">    Flowable&lt;Integer&gt; mergeFlowable = Flowable.merge(publisherList);</span><br><span class="line">    mergeFlowable.subscribe(<span class="keyword">new</span> <span class="title class_">ConsoleSubscribe</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread:【main】 在 2023-04-04T14:49:24.360Z 开启注册消费！</span><br><span class="line">Thread:【main】 在 2023-04-04T14:49:24.840Z 消费了 data【0】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:49:25.165Z 消费了 data【1】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:49:25.487Z 消费了 data【2】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:49:26.028Z 消费了 data【3】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:49:26.371Z 消费了 data【4】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:49:27.210Z 消费了 data【5】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:49:28.257Z 消费了 data【6】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:49:28.702Z 消费了 data【7】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:49:28.904Z 消费了 data【8】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:49:29.696Z 消费了 data【9】</span><br><span class="line">Thread:【main】 在 2023-04-04T14:49:29.696Z 完成了消费</span><br></pre></td></tr></table></figure><p>从结果中我们看得出来，它确实是按照我们添加<code>Flowable</code>的顺序进行的消息消费，纵使每个消息都有各自的延迟，它还是会等待着前一个消息消费完成，才进行后面的消息消费，这样是不符合我们的预期的，我们希望的是这 10 个消息能够尽可能快地在同一时间并行消费，那么我们有没有什么办法做到这一点呢？</p><pre><code>答案是没有，对于`merge`的定义，其实只是将所有`Publisher`中所需要传递的数据扁平化，供给给下游使用。</code></pre><p>所以它适用的场景，是对于多方<code>同源数据</code>或者<code>异构数据</code>进行合并处理，以满足下游的消费。、<br>所以我们还得继续跟踪<code>Flowable</code>的下一种创建方式</p><p>相关代码地址:<a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> rxjava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100DaysCode-Day05 再看RxJava:创建Flowable（二）</title>
      <link href="/2023/04/03/100dayscode-5/"/>
      <url>/2023/04/03/100dayscode-5/</url>
      
        <content type="html"><![CDATA[<pre><code>上次我们制作了简单的`心跳包`，那除了`心跳`以外我们还能做些什么呢。在对创建方法的探索中，我们又发现了一个带有类似`interval`方法签名的一个方法</code></pre><h3 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h3><p>其最简单的方法签名为：</p><ul><li><code>public static Flowable&lt;Long&gt; timer(long delay, @NonNull TimeUnit unit)</code><br>从其方法的说明文档中，我们可以看到它的声明，是可以在延迟一定的时间后，发送一个<code>0L</code>供给下游消费</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateFlowable</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Long&gt; flowable = Flowable.timer(<span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    flowable.subscribe(<span class="keyword">new</span> <span class="title class_">ConsoleSubscribe</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们同样去简单的使用一下，我们只得到了一句注册成功的打印：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread:【main】 在 2023-04-03T13:09:49.346Z 开启注册消费！</span><br></pre></td></tr></table></figure><p>那么加上死循环之后，我们再次运行：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Thread:【main】 在 2023-04-03T13:11:26.225Z 开启注册消费！</span><br><span class="line">Thread:【RxComputationThreadPool-1】 在 2023-04-03T13:11:36.236Z 消费了 data【0】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 在 2023-04-03T13:11:36.238Z 完成了消费</span><br></pre></td></tr></table></figure><p>我们得到了以上结果，那么这种结合上一次的<code>interval</code>我们貌似得到了前端同学经常使用的两个工具，一个<code>定时任务</code>和一个<code>延迟任务</code>，那么有了这两个方便的工具我们能用来做一些什么有趣的东西呢？</p><p>相关代码地址:<a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> rxjava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100DaysCode-Day04 再看RxJava:创建Flowable（一）</title>
      <link href="/2023/04/02/100dayscode-4/"/>
      <url>/2023/04/02/100dayscode-4/</url>
      
        <content type="html"><![CDATA[<pre><code>在探索能够用已学习的知识能够用来做些什么东西的时候，本来想着来制作一个`心跳器`的，却发现还没有很好的办法去创建一个`心跳`，本着对于心跳的理解，所以心跳信号应该是用`Flowable`这种消息发布体来进行，提供所以，又得去探索一下关于`Flowable`的一些操作知识。</code></pre><blockquote><p>在第一次创建<code>Flowable</code>的时候看到他有很多的静态方法，那么就浅看一下有没有适合<code>心跳</code>的创建方式</p></blockquote><h3 id="interval"><a href="#interval" class="headerlink" title="interval"></a>interval</h3><p>我们找到他看上去最简单的方法签名：</p><ul><li><code>public static Flowable&lt;Long&gt; interval(long period, @NonNull TimeUnit unit)</code><br>结合到方法的说明文档。我们知道这个方法可以让我们创建一个不断输出有序数字的发射器。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">generateFlowable</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Long&gt; intervalFlowable = Flowable.interval(<span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">    intervalFlowable.subscribe(<span class="keyword">new</span> <span class="title class_">ConsoleSubscribe</span>());</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们运行这段代码，只得到了一串打印信息（<code>ConsoleSubscribe</code>是我编写的一个会打印出模板信息<code>Thead - Time - Data</code>的<code>Subscribe</code>实现）:</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thread:【main】 在 2023-04-03T12:54:23.243Z 开启注册消费！</span><br></pre></td></tr></table></figure><p>所以可以看到我们确实注册成功了，但是并没有执行消费。我们猜测是不是因为消息的传递不是在<code>main</code>线程执行的，所以我们添加一个死循环，来监控一下，最后得到了我们预取的打印数据：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Thread:【main】 在 2023-04-03T12:57:13.927Z 开启注册消费！</span><br><span class="line">Thread:【RxComputationThreadPool-1】 在 2023-04-03T12:57:14.937Z 消费了 data【0】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 在 2023-04-03T12:57:15.942Z 消费了 data【1】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 在 2023-04-03T12:57:16.951Z 消费了 data【2】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 在 2023-04-03T12:57:17.942Z 消费了 data【3】</span><br></pre></td></tr></table></figure><p>确实是在一个线程池中进行了数据消费。那么自此我们的一个微型的<code>心跳</code>就制作完成了，目前只会进行简单的打印（取决于你对<code>Subscribe</code>的具体实现）</p><p>相关代码地址:<a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> rxjava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100dayscode-3 再看RxJava:Scheduler</title>
      <link href="/2023/04/01/100dayscode-3/"/>
      <url>/2023/04/01/100dayscode-3/</url>
      
        <content type="html"><![CDATA[<p>经过昨天的学习，我们认识到了可以如何去消费我们<code>Flowable</code>创建出来的消息，那么现在存在一个疑问，那么它是在那个线程去执行的呢。我们用一个新的方式<code>range</code>去创建一个例子尝试一下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testSchedule</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; flowable = Flowable.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">Disposable</span> <span class="variable">subscribe</span> <span class="operator">=</span> flowable</span><br><span class="line">            .subscribe(data -&gt; System.out</span><br><span class="line">                    .println(<span class="string">&quot;Thread:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】 消费了 data【&quot;</span> + data + <span class="string">&quot;】&quot;</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread:【main】 消费了 data【0】</span><br><span class="line">Thread:【main】 消费了 data【1】</span><br><span class="line">Thread:【main】 消费了 data【2】</span><br><span class="line">Thread:【main】 消费了 data【3】</span><br><span class="line">Thread:【main】 消费了 data【4】</span><br><span class="line">Thread:【main】 消费了 data【5】</span><br><span class="line">Thread:【main】 消费了 data【6】</span><br><span class="line">Thread:【main】 消费了 data【7】</span><br><span class="line">Thread:【main】 消费了 data【8】</span><br><span class="line">Thread:【main】 消费了 data【9】</span><br></pre></td></tr></table></figure><p>那么如果我们要让他<code>异步执行</code>该怎么办呢？经过对 API 的排查我们发现了几个特别的方法签名：</p><blockquote><ol><li><code>public final Flowable&lt;T&gt; subscribeOn(@NonNull Scheduler scheduler)</code></li><li><code>public final Flowable&lt;T&gt; subscribeOn(@NonNull Scheduler scheduler, boolean requestOn)</code></li><li><code>public final Flowable&lt;T&gt; unsubscribeOn(@NonNull Scheduler scheduler)</code></li></ol></blockquote><p>从这个<code>Scheduler</code>的文档里面我们发现这样一句话：<br>You can get various standard, RxJava-specific instances of this class via the static methods of the io.reactivex.rxjava3.schedulers.Schedulers utility class.</p><p>那么在不太熟悉的情况下，我们就按照官方文档的建议我们去看一下这个<code>Schedulers</code>里面携带了什么标准内容给我们使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Scheduler IO;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Scheduler COMPUTATION;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Scheduler SINGLE;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Scheduler TRAMPOLINE;</span><br><span class="line"></span><br><span class="line"><span class="meta">@NonNull</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Scheduler NEW_THREAD;</span><br></pre></td></tr></table></figure><p>我们分别来使用一下看一下效果</p><h3 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScheduleIo</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; flowable = Flowable.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    flowable = flowable</span><br><span class="line">            .subscribeOn(Schedulers.io());</span><br><span class="line">    <span class="type">Disposable</span> <span class="variable">subscribe</span> <span class="operator">=</span> flowable</span><br><span class="line">            .subscribe(data -&gt; System.out</span><br><span class="line">                    .println(<span class="string">&quot;Thread:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】 消费了 data【&quot;</span> + data + <span class="string">&quot;】&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h4><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【0】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【1】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【2】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【3】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【4】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【5】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【6】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【7】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【8】</span><br><span class="line">Thread:【RxCachedThreadScheduler-1】 消费了 data【9】</span><br></pre></td></tr></table></figure><h4 id="使用的结论"><a href="#使用的结论" class="headerlink" title="使用的结论"></a>使用的结论</h4><p>建立一单独的线程来处理数据，看起来时在背后建立了一个线程池，那么我们看一下官方文档是怎么介绍的<br>Returns a default, shared Scheduler instance intended for IO-bound work.<br>This can be used for asynchronously performing blocking IO.<br>The implementation is backed by a pool of single-threaded ScheduledExecutorService instances that will try to reuse previously started instances used by the worker returned by Scheduler</p><h3 id="COMPUTATION"><a href="#COMPUTATION" class="headerlink" title="COMPUTATION"></a>COMPUTATION</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScheduleIo</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; flowable = Flowable.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    flowable = flowable</span><br><span class="line">            .subscribeOn(Schedulers.io());</span><br><span class="line">    <span class="type">Disposable</span> <span class="variable">subscribe</span> <span class="operator">=</span> flowable</span><br><span class="line">            .subscribe(data -&gt; System.out</span><br><span class="line">                    .println(<span class="string">&quot;Thread:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】 消费了 data【&quot;</span> + data + <span class="string">&quot;】&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h4><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【0】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【1】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【2】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【3】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【4】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【5】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【6】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【7】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【8】</span><br><span class="line">Thread:【RxComputationThreadPool-1】 消费了 data【9】</span><br></pre></td></tr></table></figure><h4 id="使用的结论-1"><a href="#使用的结论-1" class="headerlink" title="使用的结论"></a>使用的结论</h4><p>建立一单独的线程来处理数据，看起来时在背后建立了一个线程池，那么我们看一下官方文档是怎么介绍的<br>Returns a default, shared Scheduler instance intended for computational work.<br>This can be used for event-loops, processing callbacks and other computational work.<br>It is not recommended to perform blocking, IO-bound work on this scheduler. Use io() instead.<br>从说明里面看，如果执行过程中没有阻塞行为的话，可以使用这个类型</p><h3 id="SINGLE"><a href="#SINGLE" class="headerlink" title="SINGLE"></a>SINGLE</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScheduleComputation</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; flowable = Flowable.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    flowable = flowable</span><br><span class="line">            .subscribeOn(Schedulers.computation());</span><br><span class="line">    <span class="type">Disposable</span> <span class="variable">subscribe</span> <span class="operator">=</span> flowable</span><br><span class="line">            .subscribe(data -&gt; System.out</span><br><span class="line">                    .println(<span class="string">&quot;Thread:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】 消费了 data【&quot;</span> + data + <span class="string">&quot;】&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果-2"><a href="#结果-2" class="headerlink" title="结果"></a>结果</h4><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【0】</span><br><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【1】</span><br><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【2】</span><br><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【3】</span><br><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【4】</span><br><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【5】</span><br><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【6】</span><br><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【7】</span><br><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【8】</span><br><span class="line">Thread:【RxSingleScheduler-1】 消费了 data【9】</span><br></pre></td></tr></table></figure><h4 id="使用的结论-2"><a href="#使用的结论-2" class="headerlink" title="使用的结论"></a>使用的结论</h4><p>建立一单独的线程来处理数据，看起来时在背后建立了一个线程池，那么我们看一下官方文档是怎么介绍的<br>Returns a default, shared, single-thread-backed Scheduler instance for work requiring strongly-sequential execution on the same background thread.</p><h3 id="TRAMPOLINE"><a href="#TRAMPOLINE" class="headerlink" title="TRAMPOLINE"></a>TRAMPOLINE</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScheduleComputation</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; flowable = Flowable.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    flowable = flowable</span><br><span class="line">            .subscribeOn(Schedulers.computation());</span><br><span class="line">    <span class="type">Disposable</span> <span class="variable">subscribe</span> <span class="operator">=</span> flowable</span><br><span class="line">            .subscribe(data -&gt; System.out</span><br><span class="line">                    .println(<span class="string">&quot;Thread:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】 消费了 data【&quot;</span> + data + <span class="string">&quot;】&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果-3"><a href="#结果-3" class="headerlink" title="结果"></a>结果</h4><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread:【main】 消费了 data【0】</span><br><span class="line">Thread:【main】 消费了 data【1】</span><br><span class="line">Thread:【main】 消费了 data【2】</span><br><span class="line">Thread:【main】 消费了 data【3】</span><br><span class="line">Thread:【main】 消费了 data【4】</span><br><span class="line">Thread:【main】 消费了 data【5】</span><br><span class="line">Thread:【main】 消费了 data【6】</span><br><span class="line">Thread:【main】 消费了 data【7】</span><br><span class="line">Thread:【main】 消费了 data【8】</span><br><span class="line">Thread:【main】 消费了 data【9】</span><br></pre></td></tr></table></figure><h4 id="使用的结论-3"><a href="#使用的结论-3" class="headerlink" title="使用的结论"></a>使用的结论</h4><p>从结果来看，它还是使用了当前线程处理，因为现在的执行线程是 Main 线程，所以我们拿到的也是 Main 线程<br>The default implementation’s Scheduler.scheduleDirect(Runnable) methods execute the tasks on the current thread without any queueing and the timed overloads use blocking sleep as well</p><h3 id="NEW-THREAD"><a href="#NEW-THREAD" class="headerlink" title="NEW_THREAD"></a>NEW_THREAD</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">testScheduleComputation</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; flowable = Flowable.range(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line">    flowable = flowable</span><br><span class="line">            .subscribeOn(Schedulers.computation());</span><br><span class="line">    <span class="type">Disposable</span> <span class="variable">subscribe</span> <span class="operator">=</span> flowable</span><br><span class="line">            .subscribe(data -&gt; System.out</span><br><span class="line">                    .println(<span class="string">&quot;Thread:【&quot;</span> + Thread.currentThread().getName() + <span class="string">&quot;】 消费了 data【&quot;</span> + data + <span class="string">&quot;】&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="结果-4"><a href="#结果-4" class="headerlink" title="结果"></a>结果</h4><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【0】</span><br><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【1】</span><br><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【2】</span><br><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【3】</span><br><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【4】</span><br><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【5】</span><br><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【6】</span><br><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【7】</span><br><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【8】</span><br><span class="line">Thread:【RxNewThreadScheduler-1】 消费了 data【9】</span><br></pre></td></tr></table></figure><h4 id="使用的结论-4"><a href="#使用的结论-4" class="headerlink" title="使用的结论"></a>使用的结论</h4><p>建立一单独的线程来处理数据，看起来时在背后建立了一个线程池，那么我们看一下官方文档是怎么介绍的<br>Returns a default, shared Scheduler instance that creates a new Thread for each unit of work.</p><p>综上俩看，基本上每一个特定的标准都是创建了一个线程池来办这个事情，那么现实真的是不是呢，我们后面在真正的使用的时候，我们再去追一下源码看看具体情况，但是现在有一个问题，如果我自己有一个线程池，我能不能使用我自己的线程池呢，从方法签名中我们有找到几个特定的方法：</p><blockquote><ol><li><code>public static Scheduler from(@NonNull Executor executor)</code></li><li><code>public static Scheduler from(@NonNull Executor executor, boolean interruptibleWorker)</code></li><li><code>public static Scheduler from(@NonNull Executor executor, boolean interruptibleWorker, boolean fair</code></li></ol></blockquote><p>从这里我们看到，确实我们能够使用自己的线程池，所以接下来我们看一下我们应该如何去使用我们现在学习过的知识点。</p><p>相关代码地址:<a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> rxjava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100DaysCode-Day02 再看RxJava:Subscribe</title>
      <link href="/2023/03/31/100dayscode-2/"/>
      <url>/2023/03/31/100dayscode-2/</url>
      
        <content type="html"><![CDATA[<p>在昨天的使用我们，我们是用了最简单的 RxJava 的模型，在这里我们回顾一下我们是如何订阅了消息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Disposable</span> <span class="variable">subscribe</span> <span class="operator">=</span> flowable.subscribe(System.out::println);</span><br></pre></td></tr></table></figure><p>这里使用了 subscibe 方法的一个重载方法，其实它总共有其中不同的声明</p><blockquote><ol><li><code>public final Disposable subscribe()</code></li><li><code>public final Disposable subscribe(@NonNull Consumer&lt;? super T&gt; onNext)</code></li><li><code>public final Disposable subscribe(@NonNull Consumer&lt;? super T&gt; onNext, @NonNull Consumer&lt;? super Throwable&gt; onError)</code></li><li><code>public final Disposable subscribe(@NonNull Consumer&lt;? super T&gt; onNext, @NonNull Consumer&lt;? super Throwable&gt; onError,@NonNull Action onComplete)</code></li><li><code>public final Disposable subscribe(@NonNull Consumer&lt;? super T&gt; onNext,@NonNull Consumer&lt;? super Throwable&gt; onError,@NonNull Action onComplete,@NonNull DisposableContainer container)</code></li><li><code>public final void subscribe(@NonNull Subscriber&lt;? super T&gt; subscriber)</code></li><li><code>public final void subscribe(@NonNull FlowableSubscriber&lt;? super T&gt; subscriber)</code></li></ol></blockquote><p>其中我们主要来看一下序号<code>6</code>的方法重载，其他的方法重载，是为了方便取使用而做的一些简化。<br>从签名中我们就注意到了一个对象<code>Subscriber&lt;? super T&gt;</code>，那么它的组成部分到底是什么样的，我们来看一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Subscriber&lt;Integer&gt; subscriber = <span class="keyword">new</span> <span class="title class_">Subscriber</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Subscription s)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(Integer o)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>从接口的方法签名上，我们就可以明确的看到，这里有四个接口方法需要我们实现，那么就可以<code>Flowable</code>的消息进行订阅了。如果要达到昨天效果，我们只需要取实现对应的<code>onNext</code>和<code>onSubscribe</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Flowable&lt;Integer&gt; flowable = Flowable.just(<span class="number">1</span>);</span><br><span class="line">Subscriber&lt;Integer&gt; subscriber = <span class="keyword">new</span> <span class="title class_">Subscriber</span>&lt;Integer&gt;() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Subscription s)</span> &#123;</span><br><span class="line">      s.request(Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onNext</span><span class="params">(Integer o)</span> &#123;</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onError</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onComplete</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">flowable.subscribe(subscriber);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>一定要注意<code>onSubscribe</code>方法，按照接口的说明，如果没有对<code>Subscription</code>进行 request 操作的话，那么其实<code>Publisher</code>并不会发送消息，这里为什么用<code>s.request(Long.MAX_VALUE)</code>,其实当你去看对应的重载发放的时候，你就会发现当我们用其他的重载方法的时候，他会去做这样一个组装，帮我们构造一个<code>LambdaSubscriber</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LambdaSubscriber&lt;T&gt; ls = <span class="keyword">new</span> <span class="title class_">LambdaSubscriber</span>&lt;&gt;(onNext, onError, onComplete, FlowableInternalHelper.RequestMax.INSTANCE);</span><br></pre></td></tr></table></figure><p>那么这里就看得到有一个<code>单例对象FlowableInternalHelper.RequestMax.INSTANCE</code>,那我们再看一下它指代的是什么</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> <span class="title class_">RequestMax</span> <span class="keyword">implements</span> <span class="title class_">Consumer</span>&lt;Subscription&gt; &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">accept</span><span class="params">(Subscription t)</span> &#123;</span><br><span class="line">        t.request(Long.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以这就是为什么我们也用这个的原因，那我们可不可以用其他的数值来代替呢？，当我们把他换成任意一个数值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">onSubscribe</span><span class="params">(Subscription s)</span> &#123;</span><br><span class="line">    s.request(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们会发现，它在现在的上下文上，确实也得到了我们的预期，但是如果我们将上下文做一个处理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Flowable&lt;Integer&gt; flowable = Flowable.just(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>);</span><br></pre></td></tr></table></figure><p>那么这个时候，你就会发现它打印了 1 之后就再也没有其他的打印了。所以我们再去看一下 <code>Subscription</code>的<code>request(long)</code>方法的说明文档，我们就会发现，它说明了这里是用来限制到底能够最多拿到<code>Publisher</code>发送的多少个消息，所以我们在这里可以大胆的假设它的使用场景：</p><ul><li>定量的心跳包发送</li><li>请求限流<br>那么剩下的<code>onNext</code>方法、<code>onError</code>方法、<code>onComplete</code>方法我们就见名知意了，分别是用于处理每一次获取到消息、发生异常时的处理、消息完全接收完毕之后的处理。到后续我们需要的时候再回过头来继续看看，他们有没有什么可以利用的点。</li></ul><p>相关代码地址:<a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> rxjava </tag>
            
            <tag> 小知识 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100DaysCode-Day01 再看RxJava:Hello Flowable</title>
      <link href="/2023/03/30/100dayscode-1/"/>
      <url>/2023/03/30/100dayscode-1/</url>
      
        <content type="html"><![CDATA[<p>在我的工作中，我使用最多的场景就是用 RxJava 帮助我处理异步任务的问题，所以对于 RxJava 的起步我应该是从<code>Flowable</code>开始切入的。那么这里就浅讲一下<code>Flowable</code>的使用方式（总的来说 RxJava 的几乎所有的<code>被观察者</code>都是这样创建的）。</p><blockquote><p>它可能不对，但是我确实是这样入坑的</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createFlowable</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; flowable = Flowable.just(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了这样的一个简单的包含一个可被监控元素的 Flowable 的被监听者已经创建好了，当运行代码的时候，会发现什么也没有发生，是因为只有被监听者准备好了，他还没有被监听。所以我们就需要让他被监听起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createFlowable</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; flowable = Flowable.just(<span class="number">1</span>);</span><br><span class="line">    flowable.subscribe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样运行之后发现，还是什么变化也没有，是因为监听者并没有做任何的事情，那么就需要给他定制一个当监听到对应的数据的时候的一个行为。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">createFlowable</span><span class="params">()</span> &#123;</span><br><span class="line">    Flowable&lt;Integer&gt; flowable = Flowable.just(<span class="number">1</span>);</span><br><span class="line">    <span class="type">Disposable</span> <span class="variable">subscribe</span> <span class="operator">=</span> flowable.subscribe(System.out::println);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样执行后，我们就会发现，我们声明了他只需要简单的打印一下拿到的数据就可以了，运行之后我们也拿到了对应的结果</p><figure class="highlight console"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure><p>至此一个简易的 RxJava 的模型就已经完成了，他可以说是 RxJava 的全部内容，也可以说是冰山一角，剩下的中间操作、监听者的配置以及<code>Disposable</code>则是接下来需要深入理解的东西。</p><p>代码地址:<a href="https://github.com/dgjungleP/100days-code-round1">100daysCode</a></p>]]></content>
      
      
      <categories>
          
          <category> 挑战 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 挑战 </tag>
            
            <tag> rxjava </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开始</title>
      <link href="/2023/03/28/test-layout/"/>
      <url>/2023/03/28/test-layout/</url>
      
        <content type="html"><![CDATA[<p>现在 从这里开始启程吧</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 生活随记 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
